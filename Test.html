    <<!DOCTYPE html>
<html lang="gu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vidushi AI - Emotional Intelligent Assistant</title>
    <link rel="manifest" href="manifest.json">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>

    <script src="vanshavali_data.js"></script>

    <style>
        /* ============ CORE STYLES ============ */
        body, html { 
            margin: 0; 
            padding: 0; 
            width: 100%; 
            height: 100%; 
            overflow: hidden; 
            background-color: black; 
            font-family: 'Segoe UI', sans-serif; 
            user-select: none; 
        }
        
        #video-container { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            z-index: 1; 
        }
        
        video { 
            width: 100%; 
            height: 100%; 
            object-fit: cover; 
            position: absolute; 
            display: none; 
        }
        
        #silent-video { 
            display: block; 
        }
        
        #selfie-video { 
            display: none; 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            object-fit: cover; 
            z-index: 5; 
            border: 4px solid #ff4500; 
        }
        
        #canvas-capture { 
            display: none; 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            z-index: 100; 
            pointer-events: none; 
        }
        
        /* RAG STATUS UI */
        #rag-status { 
            display: none; 
            position: fixed; 
            top: 10px; 
            left: 50%; 
            transform: translateX(-50%); 
            background: #008cff; 
            color: white; 
            padding: 5px 15px; 
            border-radius: 20px; 
            font-size: 12px; 
            z-index: 50; 
            box-shadow: 0 0 10px #008cff; 
        }

        /* Emotional Status Panel */
        #emotion-panel { 
            display: none; 
            position: fixed; 
            top: 10px; 
            right: 80px; 
            background: rgba(0,0,0,0.7); 
            color: white; 
            padding: 8px 15px; 
            border-radius: 20px; 
            font-size: 12px; 
            z-index: 50; 
            backdrop-filter: blur(5px); 
            border: 1px solid rgba(255,255,255,0.1); 
        }
        
        /* Memory Status Panel */
        #memory-panel { 
            display: none; 
            position: fixed; 
            top: 50px; 
            right: 20px; 
            background: rgba(0,100,0,0.7); 
            color: white; 
            padding: 5px 10px; 
            border-radius: 10px; 
            font-size: 10px; 
            z-index: 50; 
            backdrop-filter: blur(5px); 
            border: 1px solid rgba(0,255,0,0.3); 
        }
        
        /* UI Elements */
        .side-btn { 
            position: fixed; 
            top: 20px; 
            right: 20px; 
            z-index: 20; 
            background: rgba(0,0,0,0.3); 
            color: white; 
            border: 1px solid rgba(255,255,255,0.2); 
            width: 45px; 
            height: 45px; 
            border-radius: 50%; 
            font-size: 20px; 
            cursor: pointer; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            backdrop-filter: blur(5px); 
            transition: 0.3s; 
        }
        
        .side-btn:active { 
            transform: scale(0.9); 
            background: #ff4500; 
        }
        
        .modal { 
            display: none; 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            background: rgba(0,0,0,0.95); 
            z-index: 200; 
            flex-direction: column; 
            padding: 20px; 
            box-sizing: border-box; 
            justify-content: center; 
            align-items: center; 
        }
        
        .notes-header { 
            width: 100%; 
            display: flex; 
            justify-content: space-between; 
            color: #ff4500; 
            font-size: 22px; 
            font-weight: bold; 
            margin-bottom: 20px; 
            border-bottom: 1px solid #333; 
            padding-bottom: 10px; 
        }
        
        .list-container { 
            overflow-y: auto; 
            flex: 1; 
            width: 100%; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
        }
        
        .list-item { 
            background: #222; 
            padding: 15px; 
            margin-bottom: 10px; 
            border-radius: 8px; 
            border-left: 4px solid #ff4500; 
            color: white; 
            width: 90%; 
            text-align: left; 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
        }
        
        .settings-box { 
            background: #222; 
            padding: 25px; 
            border-radius: 15px; 
            width: 85%; 
            max-width: 350px; 
            border: 1px solid #ff4500; 
            color: white; 
            text-align: center; 
            max-height: 85vh; 
            overflow-y: auto; 
        }
        
        input[type="text"], 
        input[type="password"], 
        input[type="number"], 
        select, 
        textarea { 
            width: 100%; 
            padding: 10px; 
            margin: 10px 0; 
            background: #333; 
            color: white; 
            border: 1px solid #555; 
            border-radius: 5px; 
            box-sizing: border-box; 
            font-size: 14px;
        }
        
        .save-btn { 
            width: 100%; 
            padding: 10px; 
            background: #ff4500; 
            border: none; 
            font-weight: bold; 
            cursor: pointer; 
            color: white; 
            margin-top: 10px; 
            border-radius: 5px; 
        }
        
        .section-title { 
            color: #aaa; 
            font-size: 12px; 
            margin-top: 15px; 
            text-transform: uppercase; 
            letter-spacing: 1px; 
            border-bottom: 1px solid #444; 
            padding-bottom: 5px; 
            text-align: left; 
        }
        
        .menu-grid { 
            display: grid; 
            grid-template-columns: 1fr 1fr 1fr 1fr; 
            gap: 10px; 
            margin-bottom: 20px; 
        }
        
        .menu-btn { 
            background: #333; 
            border: 1px solid #555; 
            color: white; 
            padding: 15px 5px; 
            border-radius: 10px; 
            cursor: pointer; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            font-size: 10px; 
            gap: 5px; 
            text-align: center; 
        }
        
        .checkbox-container { 
            display: flex; 
            align-items: center; 
            margin: 15px 0; 
            cursor: pointer; 
            justify-content: space-between; 
            background: #333; 
            padding: 10px; 
            border-radius: 5px; 
            color: white; 
        }
        
        .checkbox-container input { 
            width: auto; 
            margin: 0; 
            transform: scale(1.5); 
        }
        
        #mic-container { 
            position: fixed; 
            bottom: 30px; 
            left: 50%; 
            transform: translateX(-50%); 
            z-index: 20; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            width: 100%; 
        }
        
        #status-text { 
            color: white; 
            margin-bottom: 15px; 
            font-size: 14px; 
            background: rgba(0,0,0,0.6); 
            padding: 5px 15px; 
            border-radius: 20px; 
            backdrop-filter: blur(4px); 
            border: 1px solid rgba(255,255,255,0.2); 
            transition: 0.3s; 
        }
        
        .controls-row { 
            display: flex; 
            gap: 20px; 
            align-items: center; 
        }
        
        .round-btn { 
            width: 60px; 
            height: 60px; 
            border-radius: 50%; 
            border: none; 
            color: white; 
            font-size: 24px; 
            cursor: pointer; 
            box-shadow: 0 4px 15px rgba(0,0,0,0.5); 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            transition: 0.2s; 
        }
        
        .round-btn:active { 
            transform: scale(0.9); 
        }
        
        #mic-btn { 
            width: 75px; 
            height: 75px; 
            background: #ff4500; 
            font-size: 32px; 
            border: 4px solid rgba(255,255,255,0.2); 
        }
        
        #doc-btn { 
            background: #28a745; 
            width: 50px; 
            height: 50px; 
            font-size: 18px; 
        }
        
        #stop-btn { 
            background: #444; 
            width: 50px; 
            height: 50px; 
            font-size: 18px; 
        }
        
        .listening { 
            animation: pulse 1.5s infinite; 
            background: red !important; 
        }
        
        #image-overlay { 
            display: none; 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            background: rgba(0,0,0,0.95); 
            z-index: 200; 
            flex-direction: column; 
            justify-content: center; 
            align-items: center; 
        }
        
        #generated-image { 
            max-width: 95%; 
            max-height: 60vh; 
            border-radius: 10px; 
            border: 3px solid #ff4500; 
            box-shadow: 0 0 30px #ff4500; 
            background: #111; 
            display: none; 
        }
        
        #image-loading-text { 
            color: #ff4500; 
            margin-top: 10px; 
            font-weight: bold; 
            display: none; 
        }
        
        .overlay-btns { 
            display: flex; 
            gap: 20px; 
            margin-top: 20px; 
        }
        
        #download-btn { 
            padding: 10px 25px; 
            background: #00ff00; 
            color: black; 
            border: none; 
            border-radius: 50px; 
            font-weight: bold; 
            cursor: pointer; 
            font-size: 16px; 
            display: none; 
        }
        
        #close-img-btn { 
            padding: 10px 25px; 
            background: red; 
            color: white; 
            border: none; 
            border-radius: 50px; 
            font-weight: bold; 
            cursor: pointer; 
            font-size: 16px; 
        }

        /* Emotional UI Elements */
        .emotion-indicator {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 11px;
            margin-left: 10px;
            font-weight: bold;
            animation: pulse 2s infinite;
        }

        .emotion-happy { 
            background: rgba(255,215,0,0.2); 
            color: #FFD700; 
            border: 1px solid rgba(255,215,0,0.5); 
        }
        
        .emotion-sad { 
            background: rgba(65,105,225,0.2); 
            color: #4169E1; 
            border: 1px solid rgba(65,105,225,0.5); 
        }
        
        .emotion-angry { 
            background: rgba(255,69,0,0.2); 
            color: #FF4500; 
            border: 1px solid rgba(255,69,0,0.5); 
        }
        
        .emotion-excited { 
            background: rgba(0,255,255,0.2); 
            color: #00ffff; 
            border: 1px solid rgba(0,255,255,0.5); 
        }
        
        .emotion-neutral { 
            background: rgba(255,255,255,0.1); 
            color: #aaa; 
            border: 1px solid rgba(255,255,255,0.2); 
        }
        
        /* Memory UI */
        .memory-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 10px;
            margin-left: 5px;
            background: rgba(0,255,0,0.2);
            color: #0f0;
            border: 1px solid rgba(0,255,0,0.5);
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        @keyframes memoryGlow {
            0% { box-shadow: 0 0 5px #0f0; }
            50% { box-shadow: 0 0 15px #0f0; }
            100% { box-shadow: 0 0 5px #0f0; }
        }

        /* SMART LENS */
        #archeology-selector { 
            display: none; 
            position: fixed; 
            bottom: 120px; 
            left: 50%; 
            transform: translateX(-50%); 
            background: #222; 
            border: 2px solid #d4af37; 
            border-radius: 15px; 
            padding: 15px; 
            z-index: 150; 
            flex-direction: column; 
            gap: 10px; 
            width: 90%; 
            max-width: 400px; 
        }
        
        .lens-modes { 
            display: grid; 
            grid-template-columns: 1fr 1fr 1fr; 
            gap: 8px; 
            margin-bottom: 10px; 
        }
        
        .mode-btn { 
            background: #333; 
            color: #aaa; 
            border: 1px solid #555; 
            padding: 10px; 
            border-radius: 8px; 
            font-size: 12px; 
            text-align: center; 
            cursor: pointer; 
        }
        
        .mode-btn.active { 
            background: #d4af37; 
            color: black; 
            font-weight: bold; 
            border-color: #fff; 
        }
        
        .action-row { 
            display: flex; 
            justify-content: space-around; 
            border-top: 1px solid #444; 
            padding-top: 10px; 
            width: 100%; 
        }
        
        .arch-btn { 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            color: white; 
            cursor: pointer; 
        }
        
        .arch-btn i { 
            font-size: 24px; 
            margin-bottom: 5px; 
            color: #008cff; 
        }

        #report-content-area { 
            width: 100%; 
            height: 60vh; 
            background: #111; 
            color: #ddd; 
            border: 1px solid #555; 
            padding: 10px; 
            font-family: monospace; 
            font-size: 14px; 
            resize: none; 
            border-radius: 5px; 
            margin-bottom: 10px; 
        }

        /* GENERATIVE UI */
        #app-viewer-modal { 
            display: none; 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            background: #000; 
            z-index: 300; 
            flex-direction: column; 
        }
        
        #app-viewer-header { 
            padding: 15px; 
            background: #222; 
            border-bottom: 2px solid #ff4500; 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            color: white; 
            font-weight: bold; 
        }
        
        #app-render-area { 
            flex: 1; 
            width: 100%; 
            background: white; 
            overflow: auto; 
            position: relative; 
        }
        
        #app-render-area body { 
            font-family: sans-serif; 
            padding: 20px; 
        }

        /* 3D UNIVERSE */
        #vanshavali-3d-modal { 
            display: none; 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            background: #000; 
            z-index: 300; 
        }
        
        #graph-container { 
            width: 100%; 
            height: 100%; 
        }
        
        #close-3d-btn { 
            position: fixed; 
            top: 20px; 
            right: 20px; 
            background: red; 
            color: white; 
            border: none; 
            padding: 10px 20px; 
            font-weight: bold; 
            z-index: 301; 
            cursor: pointer; 
            border-radius: 5px; 
        }
        
        #graph-instruction { 
            position: fixed; 
            bottom: 20px; 
            left: 50%; 
            transform: translateX(-50%); 
            color: rgba(255,255,255,0.5); 
            z-index: 301; 
            pointer-events: none; 
            font-size: 12px; 
        }

        /* Emotional Dashboard */
        .eq-meter { 
            display: inline-block; 
            margin-left: 10px; 
        }
        
        .eq-bar { 
            display: inline-block; 
            width: 40px; 
            height: 6px; 
            background: #333; 
            border-radius: 3px; 
            margin-left: 5px; 
            vertical-align: middle; 
        }
        
        .eq-fill { 
            height: 100%; 
            background: linear-gradient(90deg, #00ff00, #ffff00); 
            border-radius: 3px; 
            transition: width 0.3s ease; 
        }
        
        /* Memory Dashboard */
        .memory-progress { 
            width: 100%; 
            height: 6px; 
            background: #333; 
            border-radius: 3px; 
            margin: 5px 0; 
        }
        
        .memory-progress-fill { 
            height: 100%; 
            background: linear-gradient(90deg, #00ff00, #00ff88); 
            border-radius: 3px; 
            transition: width 0.5s ease; 
        }
        
        /* New animation for notifications */
        @keyframes slideIn {
            from { 
                transform: translateX(100%); 
                opacity: 0; 
            }
            to { 
                transform: translateX(0); 
                opacity: 1; 
            }
        }
        
        @keyframes fadeOut {
            from { 
                opacity: 1; 
            }
            to { 
                opacity: 0; 
            }
        }
        
        /* Family Tree Styles */
        .tree-node {
            padding: 10px;
            margin: 5px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            border-left: 4px solid #d4af37;
        }
        
        .tree-node-name {
            color: #00ff00;
            font-weight: bold;
            font-size: 16px;
        }
        
        .tree-node-info {
            color: #aaa;
            font-size: 12px;
            margin-top: 5px;
        }
        
        .tree-children {
            margin-left: 30px;
            border-left: 1px solid #555;
            padding-left: 15px;
        }
    </style>
</head>
<body>
    <div id="rag-status">ЁЯУД RAG Active</div>
    
    <!-- Emotional Status Panel -->
    <div id="emotion-panel">
        <span id="current-emotion">ЁЯШК ркЦрлБрк╢</span>
        <div class="eq-meter">
            <span style="color: #aaa; font-size: 10px;">EQ:</span>
            <div class="eq-bar">
                <div id="eq-bar" style="width: 70%"></div>
            </div>
            <span id="eq-score" style="color: #0ff; margin-left: 5px; font-weight: bold;">70</span>
        </div>
    </div>
    
    <!-- Memory Status Panel -->
    <div id="memory-panel">
        <span>ЁЯТ╛ <span id="memory-count">0</span> ркпрк╛ркжрлЛ</span>
    </div>
    
    <div id="video-container">
        <video id="silent-video" autoplay muted loop playsinline><source src="silent.mp4" type="video/mp4"></video>
        <video id="talking-video" muted loop playsinline><source src="talking.mp4" type="video/mp4"></video>
        <video id="thinking-video" muted loop playsinline><source src="thinking.mp4" type="video/mp4"></video>
        <video id="smiling-video" muted loop playsinline><source src="smiling.mp4" type="video/mp4"></video>
        <video id="angry-video" muted loop playsinline><source src="angry.mp4" type="video/mp4"></video>
    </div>
    
    <audio id="tts-preload-audio" src="" preload="auto"></audio>
    <video id="selfie-video" autoplay playsinline></video>
    <canvas id="canvas-capture"></canvas>

    <input type="file" id="galleryLoader" accept="image/*" style="display:none;">
    
    <input type="file" id="docLoader" accept=".pdf,.txt,.csv,.js,.html,.py" style="display:none;">

    <button id="settings-btn" class="side-btn" onclick="window.openSettings()"><i class="fas fa-cog"></i></button>

    <div id="app-viewer-modal">
        <div id="app-viewer-header">
            <span>тЬи рк╡рк┐ркжрлБрк╖рлА рк╕рк░рлНркЬрки</span>
            <button onclick="window.closeAppViewer()" style="background:red; color:white; border:none; padding:5px 15px; border-radius:5px;">ркмркВркз ркХрк░рлЛ</button>
        </div>
        <div id="app-render-area"></div>
    </div>

    <div id="vanshavali-3d-modal">
        <button id="close-3d-btn" onclick="window.close3DVanshavali()">ЁЯФЩ рккрк╛ркЫрк╛ (Back)</button>
        <div id="graph-container"></div>
        <div id="graph-instruction">ЁЯЦ▒я╕П рклрлЗрк░рк╡рк╡рк╛ ркорк╛ркЯрлЗ ркбрлНрк░рлЗркЧ ркХрк░рлЛ тАв ЁЯдП ркЭрлВрко ркХрк░рлЛ тАв ркирк╛рко рккрк░ ркХрлНрк▓рк┐ркХ ркХрк░рлЛ</div>
    </div>

    <div id="archeology-selector">
        <div style="color: #d4af37; text-align: center; font-size: 14px; margin-bottom: 5px;">ркдркорк╛рк░рлЗ рк╢рлБркВ рк╕рлНркХрлЗрки ркХрк░рк╡рлБркВ ркЫрлЗ?</div>
        <div class="lens-modes">
            <div class="mode-btn active" onclick="window.setVisionMode('history', this)">ЁЯУЬ рк╢рк┐рк▓рк╛рк▓рлЗркЦ</div>
            <div class="mode-btn" onclick="window.setVisionMode('math', this)">ЁЯФв ркЧркгрк┐ркд</div>
            <div class="mode-btn" onclick="window.setVisionMode('translate', this)">ЁЯМР ркнрк╛рк╖рк╛ркВркдрк░</div>
            <div class="mode-btn" onclick="window.setVisionMode('object', this)">ЁЯМ┐ ркУрк│ркЦ</div>
            <div class="mode-btn" onclick="window.setVisionMode('summary', this)">ЁЯУЭ рк╕рк╛рк░рк╛ркВрк╢</div>
            <div class="mode-btn" onclick="window.startLiveVision(this)" style="color: #ff4500; font-weight:bold;">тЪб рк▓рк╛ркИрк╡ рк╡рк┐ркЭрки</div>
        </div>
        <div class="action-row">
            <div class="arch-btn" onclick="window.useArcheologyCamera()"><i class="fas fa-camera"></i><span>ркХрлЗркорлЗрк░рлЛ</span></div>
            <div class="arch-btn" onclick="document.getElementById('galleryLoader').click()"><i class="fas fa-image"></i><span>ркЧрлЗрк▓рлЗрк░рлА</span></div>
            <div class="arch-btn" onclick="document.getElementById('archeology-selector').style.display='none'"><i class="fas fa-times" style="color:red;"></i><span>ркмркВркз</span></div>
        </div>
    </div>

    <div id="settings-modal" class="modal">
        <div class="settings-box">
            <h3>ркорлЗркирлВ & рк╕рлЗркЯрк┐ркВркЧрлНрк╕</h3>
            <div class="menu-grid">
                <div class="menu-btn" onclick="window.openFeature('notes')"><i class="fas fa-book" style="color:orange;"></i> ркбрк╛ркпрк░рлА</div>
                <div class="menu-btn" onclick="window.openFeature('music')"><i class="fas fa-music" style="color:#00e5ff;"></i> ркнркЬрки</div>
                <div class="menu-btn" onclick="window.openFeature('expense')"><i class="fas fa-rupee-sign" style="color:#00ff00;"></i> рк╣рк┐рк╕рк╛ркм</div>
                <div class="menu-btn" onclick="window.openFeature('contacts')"><i class="fas fa-address-book" style="color:#008cff;"></i> рк╕ркВрккрк░рлНркХрлЛ</div>
                
                <div class="menu-btn" onclick="document.getElementById('docLoader').click()"><i class="fas fa-file-pdf" style="color:red;"></i> ркжрк╕рлНркдрк╛рк╡рлЗркЬ</div>
                
                <div class="menu-btn" onclick="window.openArcheologyMenu()"><i class="fas fa-eye" style="color:#d4af37;"></i> Smart Lens</div>
                <div class="menu-btn" onclick="window.open3DVanshavali()" style="grid-column: span 2; border: 1px solid #d4af37;"><i class="fas fa-globe" style="color:#d4af37;"></i> ЁЯММ 3D рк╡ркВрк╢рк╛рк╡рк▓рлА</div>
                <div class="menu-btn" onclick="window.openEmotionalDashboard()" style="grid-column: span 2; border: 1px solid #ff4081;"><i class="fas fa-heart" style="color:#ff4081;"></i> ркнрк╛рк╡ркирк╛ ркбрлЗрк╢ркмрлЛрк░рлНркб</div>
                <div class="menu-btn" onclick="window.openMemoryDashboard()" style="grid-column: span 2; border: 1px solid #00ff00;"><i class="fas fa-brain" style="color:#00ff00;"></i> ркорлЗркорк░рлА ркбрлЗрк╢ркмрлЛрк░рлНркб</div>
            </div>

            <div class="section-title">Personal Info</div>
            <label>ркдркорк╛рк░рлБркВ ркирк╛рко:</label><input type="text" id="userNameInput" placeholder="ркжрк╛.ркд. ркжрлЗрк╡рлЗркирлНркжрлНрк░ркнрк╛ркИ">
            <label class="checkbox-container"><span>ЁЯФЗ ркЕрк╡рк╛ркЬ ркмркВркз (Silent Mode)</span><input type="checkbox" id="silentModeCheck"></label>
            <label class="checkbox-container"><span>рк╕ркдркд рк╡рк╛ркдркЪрлАркд (Hands-Free)</span><input type="checkbox" id="continuousModeCheck"></label>
            
            <div class="section-title">рк╕рлНрк╡ркнрк╛рк╡ (Personality)</div>
            <select id="moodSelect" style="border: 2px solid #ff4500; padding: 10px; font-weight: bold; background: #222; color: #ff4500;">
                <option value="normal">ЁЯШЗ ркбрк╛рк╣рлА ркбркорк░рлА (Normal)</option>
                <option value="angry">ЁЯШб ркЭркШркбрк╛рк│рлБ (Angry Mode)</option>
            </select>

            <div class="section-title">ркЕрк╡рк╛ркЬ рк╕рлЗркЯрк┐ркВркЧрлНрк╕ (Voice Settings)</div>
            <label class="checkbox-container">
                <span>ЁЯОн ркнрк╛рк╡ркирк╛ркдрлНркоркХ ркЕрк╡рк╛ркЬ (Emotional Voice)</span>
                <input type="checkbox" id="emotionalVoiceEnabled" checked>
            </label>
            <label class="checkbox-container">
                <span>ЁЯО╡ ркХрлБркжрк░ркдрлА рк▓рк╣рлЗркХрлЛ (Natural Intonation)</span>
                <input type="checkbox" id="naturalVoiceEnabled" checked>
            </label>
            
            <div class="section-title">AI Provider</div>
            <select id="providerSelect" onchange="window.toggleProviderSettings()">
                <option value="gemini">Google Gemini</option>
                <option value="groq">Groq (Llama)</option>
            </select>
            
            <div id="gemini-settings">
                <div class="section-title">Select Gemini Model</div>
                <select id="geminiModelSelect">
                    <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
                    <option value="gemini-2.5-pro">Gemini 2.5 Pro</option>
                    <option value="gemini-flash-latest">Gemini Flash Latest</option>
                    <option value="gemini-2.0-flash-exp">Gemini 2.0 Flash Exp</option>
                </select>
                <div class="section-title">API Keys</div>
                <textarea id="geminiKeyInput" rows="3" placeholder="Key1, Key2..."></textarea>
            </div>
            
            <div id="groq-settings" style="display:none;">
                <div class="section-title">Select Groq Model</div>
                <select id="groqModelSelect">
                    <option value="llama-3.1-8b-instant">Llama 3.1 8B Instant</option>
                    <option value="llama-3.3-70b-versatile">Llama 3.3 70B Versatile</option>
                    <option value="mixtral-8x7b-32768">Mixtral 8x7B</option>
                    <option value="gemma2-9b-it">Gemma2 9B</option>
                </select>
                <div class="section-title">Groq API Key</div>
                <input type="password" id="groqKeyInput" placeholder="gsk_...">
            </div>
            
            <div class="section-title">Firebase Database</div>
            <label>Firebase API Key:</label><input type="password" id="firebaseApiKeyInput" placeholder="AIzaSy...">
            
            <div class="section-title">Memory Settings</div>
            <label class="checkbox-container">
                <span>ЁЯТ╛ рк╕рлНркерк┐рк░ ркорлЗркорк░рлА рк╕ркХрлНрк░рк┐ркп (Persistent Memory)</span>
                <input type="checkbox" id="persistentMemoryEnabled" checked>
            </label>
            <label class="checkbox-container">
                <span>ЁЯФД ркЖрккркорлЗрк│рлЗ рккрлБркирк░рк╛рк╡рк░рлНркдрки (Auto Reinforcement)</span>
                <input type="checkbox" id="autoReinforcementEnabled" checked>
            </label>
            
            <button class="save-btn" onclick="window.saveSettings()">SAVE & CLOSE (SYNC)</button>
        </div>
    </div>

    <!-- Emotional Dashboard Modal -->
    <div id="emotional-dashboard-modal" class="modal">
        <div class="notes-header">
            <span>ЁЯШК ркнрк╛рк╡ркирк╛ркдрлНркоркХ ркбрлЗрк╢ркмрлЛрк░рлНркб</span>
            <span onclick="window.toggleModal('emotional-dashboard')" style="cursor:pointer">тЬЦ</span>
        </div>
        
        <div style="width: 100%; text-align: center; margin: 20px 0;">
            <div style="font-size: 48px; margin-bottom: 10px;">ЁЯШК</div>
            <div style="font-size: 24px; color: #ff4081; margin-bottom: 5px;">ркнрк╛рк╡ркирк╛ркдрлНркоркХ ркмрлБркжрлНркзрк┐: <span id="dashboard-eq-score">70</span>/100</div>
            <div style="color: #aaa; font-size: 14px;">ркдркорк╛рк░рлА EQ рк╕рлНркХрлЛрк░ рккрлНрк░ркЧркдрк┐</div>
        </div>
        
        <div style="width: 100%; padding: 20px; background: #222; border-radius: 10px; margin-bottom: 20px;">
            <h4 style="color: #ff4081; margin-bottom: 15px;">ЁЯУК ркнрк╛рк╡ркирк╛ркдрлНркоркХ рккрлНрк░рк╡рлГркдрлНркдрк┐</h4>
            <div style="color: #ddd; font-size: 14px; line-height: 1.6;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                    <span>ркЦрлБрк╢рлА (Happy):</span>
                    <span>45%</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                    <span>ркжрлБркГркЦ (Sad):</span>
                    <span>15%</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                    <span>ркЙркдрлНрк╕рк╛рк╣ (Excited):</span>
                    <span>25%</span>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <span>рк╢рк╛ркВркд (Calm):</span>
                    <span>15%</span>
                </div>
            </div>
        </div>
        
        <div style="width: 100%; margin-bottom: 20px;">
            <h4 style="color: #00bcd4; margin-bottom: 10px;">ЁЯОн ркЫрлЗрк▓рлНрк▓рлА ркнрк╛рк╡ркирк╛ркУ</h4>
            <div id="recent-emotions" style="display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;">
                <!-- Emotions will be inserted here -->
            </div>
        </div>
        
        <div style="width: 100%;">
            <h4 style="color: #4caf50; margin-bottom: 10px;">ЁЯТб ркнрк╛рк╡ркирк╛ркдрлНркоркХ ркЕркВркдрк░рлНркжрлГрк╖рлНркЯрк┐</h4>
            <div id="emotional-insights" style="background: #333; padding: 15px; border-radius: 8px; color: #ddd; font-size: 14px;">
                ркдркорк╛рк░рлА ркнрк╛рк╡ркирк╛ркдрлНркоркХ рк╕рлНркерк┐ркдрк┐ рк╕рлНркерк┐рк░ ркЫрлЗ. ркдркорлЗ рк╕ркХрк╛рк░рк╛ркдрлНркоркХ ркжрлГрк╖рлНркЯрк┐ркХрлЛркг ркЬрк╛рк│рк╡рлА рк░рк╛ркЦрлЛ ркЫрлЛ.
            </div>
        </div>
        
        <button class="save-btn" onclick="window.resetEmotionalData()" style="margin-top: 20px; background: #ff4081;">
            ЁЯФД ркбрлЗркЯрк╛ рк░рлАрк╕рлЗркЯ ркХрк░рлЛ
        </button>
    </div>

    <!-- Memory Dashboard Modal -->
    <div id="memory-dashboard-modal" class="modal">
        <div class="notes-header">
            <span>ЁЯТ╛ ркорлЗркорк░рлА ркбрлЗрк╢ркмрлЛрк░рлНркб</span>
            <span onclick="window.toggleModal('memory-dashboard')" style="cursor:pointer">тЬЦ</span>
        </div>
        
        <div style="width: 100%; text-align: center; margin: 20px 0;">
            <div style="font-size: 48px; margin-bottom: 10px;">ЁЯТ╛</div>
            <div style="font-size: 24px; color: #00ff00; margin-bottom: 5px;">ркХрлБрк▓ ркпрк╛ркжрлЛ: <span id="total-memories-count">0</span></div>
            <div style="color: #aaa; font-size: 14px;">рк╕рлНркерк┐рк░ ркорлЗркорк░рлА рк╕рк┐рк╕рлНркЯрко</div>
        </div>
        
        <div style="width: 100%; padding: 20px; background: #222; border-radius: 10px; margin-bottom: 20px;">
            <h4 style="color: #00ff00; margin-bottom: 15px;">ЁЯУК ркорлЗркорк░рлА рк╕рлНркЯрлЗркЯрк╕</h4>
            <div style="color: #ddd; font-size: 14px; line-height: 1.6;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                    <span>рк╕рлНркерк┐рк░ ркпрк╛ркжрлЛ (Long-term):</span>
                    <span id="long-term-count">0</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                    <span>ркЕрк▓рлНрккркХрк╛рк▓рк┐рки ркпрк╛ркжрлЛ (Short-term):</span>
                    <span id="short-term-count">0</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                    <span>рккрлБркирк░рк╛рк╡рк░рлНркдрки ркЬрк░рлВрк░рлА:</span>
                    <span id="due-recall-count">0</span>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <span>ркорлЗркорк░рлА ркХрлНрк╖ркоркдрк╛:</span>
                    <span id="memory-capacity">0%</span>
                </div>
            </div>
            <div class="memory-progress">
                <div id="memory-capacity-bar" class="memory-progress-fill" style="width: 0%"></div>
            </div>
        </div>
        
        <div style="width: 100%; margin-bottom: 20px;">
            <h4 style="color: #00bcd4; margin-bottom: 10px;">ЁЯФН ркдрк╛ркЬрлЗркдрк░ркирлА ркпрк╛ркжрлЛ</h4>
            <div id="recent-memories-list" style="max-height: 200px; overflow-y: auto;">
                <!-- Recent memories will be inserted here -->
            </div>
        </div>
        
        <div style="width: 100%; margin-bottom: 20px;">
            <h4 style="color: #ff9800; margin-bottom: 10px;">тЪб ркорлЗркорк░рлА ркХрлНрк░рк┐ркпрк╛ркУ</h4>
            <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                <button class="save-btn" onclick="window.consolidateAllMemories()" style="flex: 1; background: #2196f3; font-size: 12px;">
                    ЁЯФД ркмркзрлА ркпрк╛ркжрлЛ рк╕рлНркерк┐рк░ ркХрк░рлЛ
                </button>
                <button class="save-btn" onclick="window.reinforceAllMemories()" style="flex: 1; background: #4caf50; font-size: 12px;">
                    ЁЯУЪ ркмркзрлБркВ рккрлБркирк░рк╛рк╡рк░рлНркдрк┐ркд ркХрк░рлЛ
                </button>
            </div>
        </div>
        
        <div style="width: 100%;">
            <h4 style="color: #ff4081; margin-bottom: 10px;">тЪая╕П рк╕рк╛рк╡ркЪрлЗркдрлА</h4>
            <div id="memory-warnings" style="background: #333; padding: 15px; border-radius: 8px; color: #ddd; font-size: 14px;">
                ркдркорк╛рк░рлА ркпрк╛ркжрлЛ рк╕рк▓рк╛ркоркд ркЫрлЗ. ркирк┐ркпркорк┐ркд рккрлБркирк░рк╛рк╡рк░рлНркдрки ркеркИ рк░рк╣рлНркпрлБркВ ркЫрлЗ.
            </div>
        </div>
        
        <button class="save-btn" onclick="window.backupMemories()" style="margin-top: 20px; background: #00ff00; color: black;">
            ЁЯТ╛ ркмрлЗркХркЕркк рк▓рлЛ
        </button>
        <button class="save-btn" onclick="window.clearAllMemories()" style="margin-top: 10px; background: #ff0000;">
            ЁЯЧСя╕П ркмркзрлА ркпрк╛ркжрлЛ рк╕рк╛ркл ркХрк░рлЛ
        </button>
    </div>

    <div id="report-modal" class="modal">
        <div class="notes-header"><span>ЁЯУЬ рк░рк┐рккрлЛрк░рлНркЯ (Report)</span><span onclick="window.closeReport()" style="cursor:pointer">тЬЦ</span></div>
        <textarea id="report-content-area" readonly></textarea>
        <div style="display:flex; gap:10px; width:100%;">
            <button class="save-btn" onclick="window.copyReport()" style="background:#008cff;">ЁЯУЛ Copy</button>
            <button class="save-btn" onclick="window.saveReportToFile()" style="background:#00ff00; color:black;">ЁЯТ╛ Save</button>
        </div>
        <button class="save-btn" onclick="window.speakReportFromModal()" style="margin-top:10px; background:#444;">ЁЯФК рк░рк┐рккрлЛрк░рлНркЯ рк╕рк╛ркВркнрк│рлЛ</button>
    </div>

    <div id="notes-modal" class="modal">
        <div class="notes-header">
            <span>ркорк╛рк░рлА ркбрк╛ркпрк░рлА</span>
            <span onclick="window.toggleModal('notes')" style="cursor:pointer">тЬЦ</span>
        </div>
        <div id="notes-list" class="list-container"></div>
        <div style="display:flex; gap:10px; width:100%; margin-top:10px;">
            <button class="save-btn" onclick="window.speakNotes()" style="flex:1;">ЁЯФК рк╡рк╛ркВркЪ</button>
            <button class="save-btn" onclick="window.toggleModal('notes')" style="flex:1; background:#444;">ЁЯФЩ рккрк╛ркЫрк╛</button>
        </div>
    </div>
    
    <div id="music-modal" class="modal">
        <div class="notes-header">
            <span>ркнркЬрки рккрлНрк▓рлЗркпрк░</span>
            <span onclick="window.toggleModal('music')" style="cursor:pointer">тЬЦ</span>
        </div>
        <div class="list-container">
            <div class="list-item" onclick="window.playMusic('Gayatri Mantra')">ЁЯХЙя╕П ркЧрк╛ркпркдрлНрк░рлА ркоркВркдрлНрк░</div>
            <div class="list-item" onclick="window.playMusic('Hanuman Chalisa')">ЁЯЩП рк╣ркирлБркорк╛рки ркЪрк╛рк▓рлАрк╕рк╛</div>
            <div class="list-item" onclick="window.playMusic('Krishna Bhajan')">ЁЯжЪ рк╢рлНрк░рлА ркХрлГрк╖рлНркг ркнркЬрки</div>
        </div>
    </div>
    
    <div id="expense-modal" class="modal">
        <div class="notes-header">
            <span>рк╣рк┐рк╕рк╛ркм</span>
            <span onclick="window.toggleModal('expense')" style="cursor:pointer">тЬЦ</span>
        </div>
        <div style="color:#00ff00; font-size:20px; margin-bottom:10px;">ркХрлБрк▓: тВ╣<span id="total-expense">0</span></div>
        <div id="expense-list" class="list-container"></div>
        <button class="save-btn" onclick="window.clearExpenses()" style="background:red;">ЁЯЧСя╕П рк╕рк╛ркл ркХрк░рлЛ</button>
    </div>
    
    <div id="contacts-modal" class="modal">
        <div class="notes-header">
            <span>рк╕ркВрккрк░рлНркХрлЛ</span>
            <span onclick="window.toggleModal('contacts')" style="cursor:pointer">тЬЦ</span>
        </div>
        <div style="display:flex; gap:5px; width:100%;">
            <input type="text" id="contactName" placeholder="ркирк╛рко" style="flex:1;">
            <input type="number" id="contactNumber" placeholder="ркиркВркмрк░" style="flex:1;">
        </div>
        <button class="save-btn" onclick="window.addContactUI()" style="margin-bottom:15px;">Add Contact</button>
        <div id="contacts-list" class="list-container" style="width:100%;"></div>
    </div>
    
    <div id="image-overlay">
        <img id="generated-image" src="" alt="Magic Image">
        <div id="image-loading-text">ркЙркХрлЗрк▓рлА рк░рк╣рлА ркЫрлБркВ...</div>
        <div class="overlay-btns">
            <button id="download-btn" onclick="window.downloadSelfie()">тмЗ рк╕рлЗрк╡ ркХрк░рлЛ</button>
            <button id="close-img-btn" onclick="window.closeImage()">ркмркВркз ркХрк░рлЛ</button>
        </div>
    </div>

    <div id="mic-container">
        <div id="status-text">Cloud рк╕рк╛ркерлЗ ркЬрлЛркбрлБркВ ркЫрлБркВ...</div>
        <div class="controls-row">
            <button id="mic-btn" class="round-btn" onclick="window.startConversation()"><i class="fas fa-microphone"></i></button>
            <button id="stop-btn" class="round-btn" onclick="window.stopConversation()"><i class="fas fa-stop"></i></button>
        </div>
    </div>

        script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { 
            getFirestore, 
            doc, 
            onSnapshot, 
            setDoc, 
            updateDoc, 
            arrayUnion, 
            collection, 
            addDoc, 
            deleteDoc, 
            query, 
            orderBy, 
            getDocs, 
            getDoc 
        } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

        // FIREBASE CONFIG
        const firebaseConfig = {
            apiKey: localStorage.getItem('vidushi_firebase_apiKey') || "AIzaSyAexampleKey1234567890",
            authDomain: "vidushi-ai-614cb.firebaseapp.com",
            projectId: "vidushi-ai-614cb",
            storageBucket: "vidushi-ai-614cb.firebasestorage.app",
            messagingSenderId: "146312927144",
            appId: "1:146312927144:web:91bfb8c430a2124d0e6f9d",
            measurementId: "G-ZM9RS2J6SR"
        };

        // Global Variables
        let app, db, userDocRef, settingsDocRef, vanshavaliDocRef;
        let aiProvider = localStorage.getItem('vidushi_provider') || 'gemini';
        let geminiKeys = localStorage.getItem('vidushi_gemini_key') || '';
        let groqKey = localStorage.getItem('vidushi_groq_key') || '';
        let geminiModel = localStorage.getItem('vidushi_gemini_model') || "gemini-2.5-flash"; 
        let groqModel = localStorage.getItem('vidushi_groq_model') || "llama-3.1-8b-instant";
        let continuousMode = localStorage.getItem('vidushi_continuous') === 'true';
        let silentMode = localStorage.getItem('vidushi_silent') === 'true';
        let currentMood = localStorage.getItem('vidushi_mood') || 'normal'; 
        let userName = localStorage.getItem('vidushi_username') || "рк╕рк╛рк╣рлЗркм";
        let firebaseApiKey = localStorage.getItem('vidushi_firebase_apiKey') || '';
        let emotionalVoiceEnabled = localStorage.getItem('vidushi_emotional_voice') !== 'false';
        let naturalVoiceEnabled = localStorage.getItem('vidushi_natural_voice') !== 'false';
        let persistentMemoryEnabled = localStorage.getItem('vidushi_persistent_memory') !== 'false';
        let autoReinforcementEnabled = localStorage.getItem('vidushi_auto_reinforcement') !== 'false';

        // Initialize Firebase
        try {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            userDocRef = doc(db, "vidushi_db", "main_memory");
            settingsDocRef = doc(db, "vidushi_db", "settings");
            vanshavaliDocRef = doc(db, "vidushi_db", "vanshavali");
            console.log("тЬЕ Firebase initialized successfully");
            loadCloudSettings();
        } catch (err) { 
            console.error("Firebase error:", err);
            document.getElementById('status-text').innerText = "DB Error: " + err.message; 
        }

        // RAG MEMORY STORAGE
        window.ragContent = ""; 
        window.permanentMemories = window.permanentMemories || [];
        window.chatHistory = window.chatHistory || [];
        window.activeFamilyTree = window.activeFamilyTree || null;
        
        let notes = [], expenses = [], contacts = [];
        let currentCameraMode = "user";
        let isSilentListening = false;
        let conversationBuffer = "";

        const visionPrompts = {
            'history': `Analyze this image carefully. It may contain ancient scripts like Brahmi, Puranic scripts, or historical inscriptions (Shilalekh). Task: 1. Identify script. 2. Transliterate to Gujarati. 3. Translate meaning to Gujarati. Report in Gujarati.`,
            'math': `Analyze this image for math problems. Solve the problem step-by-step. Show the final answer clearly. Explain the logic in Gujarati.`,
            'translate': `Detect all text in this image. Translate it accurately into Gujarati. Maintain the formatting as much as possible.`,
            'object': `Identify the main object, plant, animal, or item in this image. Provide its name and a detailed description of its uses or characteristics in Gujarati.`,
            'summary': `Read the text in this document image. Provide a concise summary of the main points in Gujarati. Bullet points preferred.`
        };

        let currentVisionPrompt = visionPrompts['history'];
        let selectedLensMode = 'history';
        let recognition, isProcessing = false, isAiSpeaking = false;
        let visionMode = false, visionStream = null, wakeLock = null;

        // DOM Elements
        const statusText = document.getElementById('status-text');
        const micBtn = document.getElementById('mic-btn');
        const selfieVideo = document.getElementById('selfie-video');
        const canvas = document.getElementById('canvas-capture');
        const imageOverlay = document.getElementById('image-overlay');
        const generatedImage = document.getElementById('generated-image');
        const imageLoadingText = document.getElementById('image-loading-text');
        
        const videos = {
            silent: document.getElementById('silent-video'), 
            talking: document.getElementById('talking-video'),
            thinking: document.getElementById('thinking-video'), 
            smiling: document.getElementById('smiling-video'), 
            angry: document.getElementById('angry-video')
        };

        // ==================== VANSHAVALI FUNCTIONS ====================
        async function loadVanshavaliFromCloud() {
            if (!db) {
                console.log("No database, loading from local");
                loadVanshavaliFromLocal();
                return;
            }
            
            try {
                const docSnap = await getDoc(vanshavaliDocRef);
                
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    window.activeFamilyTree = data.tree || data;
                    console.log("тЬЕ Vanshavali loaded from Firebase");
                    console.log("Tree structure:", window.activeFamilyTree);
                    
                    // If tree is empty but we have local data, use local
                    if (!window.activeFamilyTree || Object.keys(window.activeFamilyTree).length === 0) {
                        loadVanshavaliFromLocal();
                    }
                } else {
                    console.log("No vanshavali in Firebase, loading from local");
                    loadVanshavaliFromLocal();
                    
                    // Save local data to Firebase
                    if (window.activeFamilyTree) {
                        await setDoc(vanshavaliDocRef, { 
                            tree: window.activeFamilyTree,
                            lastUpdated: new Date()
                        });
                        console.log("тЬЕ Saved local vanshavali to Firebase");
                    }
                }
            } catch (error) {
                console.error("тЭМ Error loading vanshavali from Firebase:", error);
                loadVanshavaliFromLocal();
            }
        }
        
        function loadVanshavaliFromLocal() {
            // Check if vanshavali_data.js is loaded
            if (typeof window.vanshavaliData !== 'undefined') {
                window.activeFamilyTree = window.vanshavaliData;
                console.log("тЬЕ Vanshavali loaded from local data file");
            } else {
                // Create default structure
                window.activeFamilyTree = {
                    name: "ркорлВрк│ рккрлБрк░рлБрк╖",
                    info: "ркХрлБрк│ркирк╛ рк╕рлНркерк╛рккркХ",
                    children: []
                };
                console.log("тЪая╕П Created default vanshavali structure");
            }
        }
        
        window.open3DVanshavali = function() {
            if (!window.activeFamilyTree) {
                window.speak("рк╡ркВрк╢рк╛рк╡рк▓рлА ркбрлЗркЯрк╛ ркорк│рлНркпрлЛ ркиркерлА. ркХрлГрккрк╛ ркХрк░рлАркирлЗ рклрк░рлА рккрлНрк░ркпрк╛рк╕ ркХрк░рлЛ.", false, 'sad');
                return;
            }
            
            document.getElementById('vanshavali-3d-modal').style.display = 'block';
            
            // Simple 3D visualization using CSS
            const graphContainer = document.getElementById('graph-container');
            graphContainer.innerHTML = `
                <div style="width:100%; height:100%; display:flex; flex-direction:column; align-items:center; justify-content:center; color:white; padding:20px; overflow-y:auto;">
                    <h2 style="color:#d4af37; margin-bottom:30px; text-align:center;">ЁЯМ│ рк╡ркВрк╢рк╛рк╡рк▓рлА - рккрк░рк┐рк╡рк╛рк░ рк╡рлГркХрлНрк╖</h2>
                    <div style="background:rgba(255,255,255,0.1); padding:30px; border-radius:15px; max-width:800px; width:100%; border:2px solid #d4af37;">
                        ${renderFamilyTreeHTML(window.activeFamilyTree)}
                    </div>
                    <div style="margin-top:20px; color:#aaa; font-size:12px; text-align:center;">
                        ркХрлБрк▓ рк╕ркнрлНркпрлЛ: ${countFamilyMembers(window.activeFamilyTree)}
                    </div>
                </div>
            `;
        };
        
        function renderFamilyTreeHTML(node, depth = 0) {
            if (!node) return '';
            
            const indent = depth * 30;
            let html = `
                <div class="tree-node" style="margin-left:${indent}px;">
                    <div class="tree-node-name">ЁЯСд ${node.name}</div>`;
            
            if (node.info) {
                html += `<div class="tree-node-info">ЁЯУЭ ${node.info}</div>`;
            }
            
            html += `</div>`;
            
            if (node.children && node.children.length > 0) {
                html += `<div class="tree-children" style="margin-left:${indent + 20}px;">`;
                node.children.forEach(child => {
                    html += renderFamilyTreeHTML(child, depth + 1);
                });
                html += `</div>`;
            }
            
            return html;
        }
        
        function countFamilyMembers(node) {
            if (!node) return 0;
            
            let count = 1; // Count current node
            
            if (node.children && node.children.length > 0) {
                node.children.forEach(child => {
                    count += countFamilyMembers(child);
                });
            }
            
            return count;
        }
        
        window.close3DVanshavali = function() {
            document.getElementById('vanshavali-3d-modal').style.display = 'none';
            window.speak("рк╡ркВрк╢рк╛рк╡рк▓рлА ркмркВркз ркХрк░рлА.", false, 'neutral');
        };
        
        // Helper function to find person in tree
        function findPersonInTree(tree, name) {
            if (!tree || !name) return null;
            
            const lowerName = name.toLowerCase();
            const lowerTreeName = tree.name.toLowerCase();
            
            if (lowerTreeName.includes(lowerName) || lowerName.includes(lowerTreeName)) {
                let info = `${tree.name}`;
                if (tree.info) info += ` - ${tree.info}`;
                
                if (tree.children && tree.children.length > 0) {
                    const childrenNames = tree.children.map(c => c.name).join(", ");
                    info += `. ${tree.children.length} рк╕ркВркдрк╛ркирлЛ: ${childrenNames}`;
                }
                
                return info;
            }
            
            if (tree.children) {
                for (let child of tree.children) {
                    const result = findPersonInTree(child, name);
                    if (result) return result;
                }
            }
            
            return null;
        }
        
        // Function to add child to parent in tree
        function addChildToParent(tree, parentName, childData) {
            if (!tree || !parentName) return false;
            
            const lowerParentName = parentName.toLowerCase();
            const lowerTreeName = tree.name.toLowerCase();
            
            if (lowerTreeName.includes(lowerParentName) || lowerParentName.includes(lowerTreeName)) {
                if (!tree.children) tree.children = [];
                tree.children.push(childData);
                return true;
            }
            
            if (tree.children) {
                for (let child of tree.children) {
                    if (addChildToParent(child, parentName, childData)) {
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        async function saveVanshavaliToCloud() {
            if (!db || !window.activeFamilyTree) return false;
            
            try {
                await setDoc(vanshavaliDocRef, { 
                    tree: window.activeFamilyTree,
                    lastUpdated: new Date()
                }, { merge: true });
                console.log("тЬЕ Vanshavali saved to Firebase");
                return true;
            } catch (error) {
                console.error("тЭМ Error saving vanshavali:", error);
                return false;
            }
        }

        // ==================== PERSISTENT MEMORY SYSTEM ====================
        class PersistentMemory {
            constructor() {
                this.longTermMemories = [];
                this.shortTermMemories = [];
                this.memoryIndex = new Map();
                this.loadFromStorage();
                
                // Set up intervals
                this.setupIntervals();
            }
            
            setupIntervals() {
                // Memory consolidation timer (every 2 hours)
                if (autoReinforcementEnabled) {
                    setInterval(() => this.consolidateMemories(), 2 * 60 * 60 * 1000);
                    
                    // Reinforcement timer (every 30 minutes for important memories)
                    setInterval(() => this.reinforceImportantMemories(), 30 * 60 * 1000);
                    
                    // Update memory panel every minute
                    setInterval(() => this.updateMemoryPanel(), 60 * 1000);
                }
            }
            
            loadFromStorage() {
                try {
                    const saved = localStorage.getItem('vidushi_long_term_memories');
                    if (saved) {
                        this.longTermMemories = JSON.parse(saved);
                        this.buildIndex();
                        console.log(`ЁЯУЪ Loaded ${this.longTermMemories.length} long-term memories`);
                    }
                } catch(e) {
                    console.error("Memory load error:", e);
                    this.longTermMemories = [];
                }
            }
            
            saveToStorage() {
                try {
                    localStorage.setItem('vidushi_long_term_memories', 
                        JSON.stringify(this.longTermMemories));
                    return true;
                } catch(e) {
                    console.error("Memory save error:", e);
                    return false;
                }
            }
            
            buildIndex() {
                this.memoryIndex.clear();
                this.longTermMemories.forEach((memory, index) => {
                    if (memory && memory.text) {
                        const keywords = this.extractKeywords(memory.text);
                        keywords.forEach(keyword => {
                            if (!this.memoryIndex.has(keyword)) {
                                this.memoryIndex.set(keyword, []);
                            }
                            this.memoryIndex.get(keyword).push(index);
                        });
                    }
                });
            }
            
            extractKeywords(text) {
                if (!text || typeof text !== 'string') return [];
                
                const words = text.toLowerCase()
                    .replace(/[^\u0A80-\u0AFF\s]/g, '')
                    .split(/\s+/)
                    .filter(word => word && word.length > 2);
                
                const stopWords = new Set(['ркЕркирлЗ', 'ркП', 'ркЖ', 'ркдрлЗ', 'ркирк╛', 'ркирлА', 'ркирлЗ', 'ркорк╛ркВ', 'ркерлА', 'рккркг', 'ркХрлЗ']);
                
                return words.filter(word => !stopWords.has(word));
            }
            
            addMemory(text, category = 'general', importance = 3) {
                if (!persistentMemoryEnabled || !text || text.trim().length === 0) {
                    return null;
                }
                
                const memory = {
                    id: Date.now().toString(36) + Math.random().toString(36).substr(2),
                    text: text.trim(),
                    category: category,
                    importance: Math.min(5, Math.max(1, importance)),
                    createdAt: new Date(),
                    lastRecalled: new Date(),
                    recallCount: 0,
                    nextRecallDue: this.calculateNextRecall(importance),
                    reinforced: false
                };
                
                // Check if similar memory exists
                const similar = this.findSimilarMemories(text);
                if (similar.length > 0) {
                    // Update existing memory
                    const existingIndex = similar[0];
                    if (this.longTermMemories[existingIndex]) {
                        const existing = this.longTermMemories[existingIndex];
                        existing.recallCount++;
                        existing.lastRecalled = new Date();
                        existing.nextRecallDue = this.calculateNextRecall(existing.importance);
                        existing.reinforced = true;
                        this.saveToStorage();
                        
                        // Show memory recall notification
                        this.showMemoryNotification("ЁЯФД ркпрк╛ркж ркдрк╛ркЬрлА ркХрк░рлА", `"${text.substring(0, 50)}..."`);
                        
                        return existing.id;
                    }
                }
                
                this.shortTermMemories.push(memory);
                
                // If high importance, immediately move to long-term
                if (importance >= 4) {
                    this.moveToLongTerm(memory);
                } else {
                    // Save to storage for short-term memories too
                    this.saveToStorage();
                }
                
                // Show memory added notification
                this.showMemoryNotification("ЁЯТ╛ ркирк╡рлА ркпрк╛ркж", `"${text.substring(0, 50)}..."`);
                
                // Update panel
                this.updateMemoryPanel();
                
                return memory.id;
            }
            
            calculateNextRecall(importance) {
                const now = new Date();
                const hours = [168, 72, 24, 12, 6]; // Importance 5-1 (weeks/days/hours)
                return new Date(now.getTime() + (hours[importance-1] || 24) * 60 * 60 * 1000);
            }
            
            findSimilarMemories(text, threshold = 0.7) {
                if (!text || text.trim().length === 0) return [];
                
                const keywords = this.extractKeywords(text);
                if (keywords.length === 0) return [];
                
                const matches = new Map();
                
                keywords.forEach(keyword => {
                    if (this.memoryIndex.has(keyword)) {
                        this.memoryIndex.get(keyword).forEach(index => {
                            matches.set(index, (matches.get(index) || 0) + 1);
                        });
                    }
                });
                
                // Convert to similarity score
                const similar = [];
                matches.forEach((count, index) => {
                    const similarity = count / keywords.length;
                    if (similarity >= threshold) {
                        similar.push({index, similarity});
                    }
                });
                
                return similar.sort((a, b) => b.similarity - a.similarity).map(s => s.index);
            }
            
            moveToLongTerm(memory) {
                if (!memory || !memory.id) return null;
                
                // Remove from short-term
                const shortIndex = this.shortTermMemories.findIndex(m => m && m.id === memory.id);
                if (shortIndex > -1) {
                    this.shortTermMemories.splice(shortIndex, 1);
                }
                
                // Add to long-term
                this.longTermMemories.push(memory);
                
                // Update index
                const keywords = this.extractKeywords(memory.text);
                const index = this.longTermMemories.length - 1;
                keywords.forEach(keyword => {
                    if (!this.memoryIndex.has(keyword)) {
                        this.memoryIndex.set(keyword, []);
                    }
                    this.memoryIndex.get(keyword).push(index);
                });
                
                this.saveToStorage();
                this.updateMemoryPanel();
                
                return memory.id;
            }
            
            consolidateMemories() {
                if (!autoReinforcementEnabled || !persistentMemoryEnabled) return;
                
                const now = new Date();
                let consolidated = 0;
                
                // Move old short-term memories to long-term
                const remainingMemories = [];
                this.shortTermMemories.forEach(memory => {
                    if (memory && memory.createdAt) {
                        const age = now - new Date(memory.createdAt);
                        const ageHours = age / (1000 * 60 * 60);
                        
                        if (ageHours > 4) { // After 4 hours, consolidate
                            this.moveToLongTerm(memory);
                            consolidated++;
                        } else {
                            remainingMemories.push(memory);
                        }
                    }
                });
                
                this.shortTermMemories = remainingMemories;
                
                if (consolidated > 0) {
                    console.log(`ЁЯУж Consolidated ${consolidated} memories to long-term`);
                    this.saveToStorage();
                }
                
                this.updateMemoryPanel();
            }
            
            reinforceImportantMemories() {
                if (!autoReinforcementEnabled || !persistentMemoryEnabled) return;
                
                const now = new Date();
                let reinforced = 0;
                
                this.longTermMemories.forEach(memory => {
                    if (memory && memory.nextRecallDue && new Date(memory.nextRecallDue) <= now) {
                        memory.recallCount = (memory.recallCount || 0) + 1;
                        memory.lastRecalled = now;
                        memory.nextRecallDue = this.calculateNextRecall(memory.importance || 3);
                        memory.reinforced = true;
                        reinforced++;
                    }
                });
                
                if (reinforced > 0) {
                    this.saveToStorage();
                    console.log(`ЁЯФД Reinforced ${reinforced} memories`);
                }
            }
            
            getRelevantMemories(query, limit = 5) {
                if (!this.longTermMemories.length || !query) return [];
                
                const similar = this.findSimilarMemories(query, 0.3);
                const results = [];
                
                similar.forEach(index => {
                    if (results.length < limit && this.longTermMemories[index]) {
                        const memory = this.longTermMemories[index];
                        const score = ((memory.recallCount || 0) + 1) * ((memory.importance || 3) / 5);
                        results.push({...memory, score, index});
                    }
                });
                
                // Sort by relevance score
                return results.sort((a, b) => b.score - a.score);
            }
            
            getAllMemories() {
                return [...this.longTermMemories, ...this.shortTermMemories].filter(m => m);
            }
            
            getMemoryCounts() {
                return {
                    longTerm: this.longTermMemories.length,
                    shortTerm: this.shortTermMemories.length,
                    total: this.longTermMemories.length + this.shortTermMemories.length,
                    dueForRecall: this.longTermMemories.filter(m => 
                        m && m.nextRecallDue && new Date(m.nextRecallDue) <= new Date()
                    ).length
                };
            }
            
            updateMemoryPanel() {
                if (!document.getElementById('memory-panel')) return;
                
                const counts = this.getMemoryCounts();
                document.getElementById('memory-count').textContent = counts.total;
                document.getElementById('memory-panel').style.display = 'block';
                
                // Update memory panel color based on status
                const panel = document.getElementById('memory-panel');
                if (counts.dueForRecall > 10) {
                    panel.style.background = 'rgba(255,100,0,0.7)';
                    panel.style.borderColor = 'rgba(255,150,0,0.5)';
                } else if (counts.dueForRecall > 5) {
                    panel.style.background = 'rgba(255,200,0,0.7)';
                    panel.style.borderColor = 'rgba(255,255,0,0.5)';
                } else {
                    panel.style.background = 'rgba(0,100,0,0.7)';
                    panel.style.borderColor = 'rgba(0,255,0,0.3)';
                }
            }
            
            showMemoryNotification(title, content) {
                // Create notification element
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 100px;
                    right: 20px;
                    background: rgba(0,100,0,0.9);
                    color: white;
                    padding: 10px 15px;
                    border-radius: 10px;
                    z-index: 1000;
                    border: 1px solid #0f0;
                    animation: slideIn 0.3s ease, fadeOut 0.3s ease 2.7s;
                    max-width: 300px;
                    backdrop-filter: blur(10px);
                `;
                
                notification.innerHTML = `
                    <div style="font-weight: bold; color: #0f0;">${title}</div>
                    <div style="font-size: 12px; margin-top: 5px;">${content}</div>
                `;
                
                document.body.appendChild(notification);
                
                // Remove after 3 seconds
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.style.animation = 'fadeOut 0.3s ease';
                        setTimeout(() => {
                            if (notification.parentNode) {
                                document.body.removeChild(notification);
                            }
                        }, 300);
                    }
                }, 3000);
            }
            
            deleteMemory(memoryId) {
                if (!memoryId) return false;
                
                // Remove from long-term
                const longIndex = this.longTermMemories.findIndex(m => m && m.id === memoryId);
                if (longIndex > -1) {
                    this.longTermMemories.splice(longIndex, 1);
                    this.buildIndex();
                    this.saveToStorage();
                    return true;
                }
                
                // Remove from short-term
                const shortIndex = this.shortTermMemories.findIndex(m => m && m.id === memoryId);
                if (shortIndex > -1) {
                    this.shortTermMemories.splice(shortIndex, 1);
                    this.saveToStorage();
                    return true;
                }
                
                return false;
            }
            
            clearAllMemories() {
                this.longTermMemories = [];
                this.shortTermMemories = [];
                this.memoryIndex.clear();
                localStorage.removeItem('vidushi_long_term_memories');
                this.updateMemoryPanel();
                return true;
            }
            
            backupMemories() {
                const backup = {
                    longTermMemories: this.longTermMemories,
                    shortTermMemories: this.shortTermMemories,
                    timestamp: new Date(),
                    version: '1.0'
                };
                
                const dataStr = JSON.stringify(backup, null, 2);
                const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
                
                const exportFileDefaultName = `vidushi_memory_backup_${new Date().toISOString().split('T')[0]}.json`;
                
                const linkElement = document.createElement('a');
                linkElement.setAttribute('href', dataUri);
                linkElement.setAttribute('download', exportFileDefaultName);
                linkElement.click();
                
                return exportFileDefaultName;
            }
            
            getRecentMemories(limit = 5) {
                const all = this.getAllMemories();
                return all
                    .sort((a, b) => {
                        const dateA = a.lastRecalled || a.createdAt;
                        const dateB = b.lastRecalled || b.createdAt;
                        return new Date(dateB) - new Date(dateA);
                    })
                    .slice(0, limit);
            }
        }

        // Initialize persistent memory system
        window.persistentMemory = new PersistentMemory();

        // ==================== EMOTIONAL INTELLIGENCE SYSTEM ====================
        class EmotionalIntelligence {
            constructor() {
                this.userEmotion = 'neutral';
                this.vidushiEmotion = 'happy';
                this.emotionHistory = [];
                this.eqScore = localStorage.getItem('vidushi_eq_score') ? parseInt(localStorage.getItem('vidushi_eq_score')) : 50;
                
                this.gujaratiEmotionKeywords = {
                    happy: ['ркЦрлБрк╢', 'рк╕рк╛рк░рлБркВ', 'ркоркЬрк╛', 'рк╣рк╕рк╡рлБркВ', 'ркЖркиркВркж', 'рккрлНрк░рлЗрко', 'ркЖркнрк╛рк░', 'рк╢рк╛ркнрк╛рк╢', 'рк╡рк╛рк╣', 'ркЕркжрлНркнрлБркд', 'рк╕рлБркВркжрк░', 'рк╕рлБркЦ', 'ркоркЬрк╛ркорк╛ркВ', 'ркЖркиркВркжркоркп'],
                    sad: ['ркжрлБркГркЦ', 'рк░ркбрк╡рлБркВ', 'ркЙркжрк╛рк╕', 'ркЪрк┐ркВркдрк╛', 'ркдркгрк╛рк╡', 'рккрлАркбрк╛', 'рк╡рлЗркжркирк╛', 'ркЕрклрк╕рлЛрк╕', 'ркирк┐рк░рк╛рк╢', 'рк╣ркдрк╛рк╢', 'ркЙркжрк╛рк╕рлА', 'ркжрлБркЦркж', 'ркжрлБркЦ', 'рк░ркбрлНркпрк╛'],
                    angry: ['ркЧрлБрк╕рлНрк╕рлЛ', 'ркХрлНрк░рлЛркз', 'ркЦрлАркЬ', 'рк░рлЛрк╖', 'ркирк╛рк░рк╛ркЬ', 'ркЧрлБрк╕рлНрк╕рлЗ', 'ркХрлЛркк', 'ркЪрлАркб', 'ркЦрк┐ркЬрк╛рк╡рк╡рлБркВ', 'ркирк╛ркЦрлБрк╢', 'ркЧрлБрк╕рлНрк╕рк╛рк╡рк╛рк░', 'ркЪрлАркв'],
                    excited: ['ркЙркдрлНрк╕рк╛рк╣', 'ркЙркдрлНркдрлЗркЬркирк╛', 'ркЙркоркВркЧ', 'ркЖркдрлБрк░', 'ркмрлЗркЪрлЗрки', 'ркЙркдрлНрк╕рлБркХ', 'ркЙркдрлНркХркВркарк╛', 'ркЙркдрлНрк╕рк╛рк╣рк┐ркд', 'ркЙркоркВркЧрлА', 'ркЖркдрлБрк░ркдрк╛'],
                    grateful: ['ркЖркнрк╛рк░', 'ркХрлГркдркЬрлНркЮ', 'ркзркирлНркпрк╡рк╛ркж', 'рк╢рлБркХрлНрк░рк┐ркпрк╛', 'ркорлЗрк╣рк░ркмрк╛ркирлА', 'ркЖркнрк╛рк░рлА', 'ркХрлГркдрк╛рк░рлНрке'],
                    calm: ['рк╢рк╛ркВркд', 'рк╕рлНркерк┐рк░', 'ркзрлАрк░ркЬ', 'рк╕ркоркдрлЛрк▓', 'рк╢рк╛ркВркдрк┐', 'ркзрлАрк░ркЧркВркнрлАрк░', 'рк╢рко', 'рк╢рк╛ркВркдрк┐рккрлВрк░рлНркг']
                };
            }

            detectEmotionFromText(text) {
                if (!text || typeof text !== 'string' || text.trim().length < 2) return 'neutral';
                
                let emotionScores = {
                    happy: 0, sad: 0, angry: 0, excited: 0, grateful: 0, calm: 0, neutral: 1
                };

                const lowerText = text.toLowerCase();
                
                for (const [emotion, keywords] of Object.entries(this.gujaratiEmotionKeywords)) {
                    keywords.forEach(keyword => {
                        if (lowerText.includes(keyword.toLowerCase())) {
                            emotionScores[emotion] += 2;
                        }
                    });
                }

                if ((text.match(/!/g) || []).length >= 2) emotionScores.excited += 3;
                if ((text.match(/\?/g) || []).length >= 2) emotionScores.neutral += 1;
                if (text.includes('...') || text.includes('тАж')) emotionScores.sad += 2;
                if ((text.match(/\./g) || []).length >= 3) emotionScores.calm += 1;

                const wordCount = text.split(' ').length;
                if (wordCount < 5) emotionScores.excited += 1;

                let dominantEmotion = 'neutral';
                let maxScore = 0;
                
                for (const [emotion, score] of Object.entries(emotionScores)) {
                    if (score > maxScore) {
                        maxScore = score;
                        dominantEmotion = emotion;
                    }
                }

                this.userEmotion = dominantEmotion;
                this.emotionHistory.push({
                    emotion: dominantEmotion,
                    text: text.substring(0, 50) + (text.length > 50 ? '...' : ''),
                    timestamp: new Date()
                });

                if (this.emotionHistory.length > 20) {
                    this.emotionHistory.shift();
                }

                this.updateEQBasedOnEmotion(dominantEmotion);

                return dominantEmotion;
            }

            updateEQBasedOnEmotion(emotion) {
                const eqChanges = {
                    happy: 1,
                    grateful: 2,
                    calm: 1,
                    excited: 0,
                    neutral: 0,
                    sad: -1,
                    angry: -2
                };
                
                this.eqScore = Math.min(100, Math.max(0, 
                    this.eqScore + (eqChanges[emotion] || 0)
                ));
                
                localStorage.setItem('vidushi_eq_score', this.eqScore);
                return this.eqScore;
            }

            getVidushiVideoForEmotion(emotion) {
                const emotionToVideo = {
                    happy: 'smiling',
                    sad: 'thinking',
                    angry: 'angry',
                    excited: 'talking',
                    grateful: 'smiling',
                    calm: 'silent',
                    neutral: 'silent'
                };
                return emotionToVideo[emotion] || 'silent';
            }

            getEmotionIcon(emotion) {
                const icons = {
                    happy: 'ЁЯШК',
                    sad: 'ЁЯШв',
                    angry: 'ЁЯШа',
                    excited: 'ЁЯОЙ',
                    grateful: 'ЁЯЩП',
                    calm: 'ЁЯШМ',
                    neutral: 'ЁЯШР'
                };
                return icons[emotion] || 'ЁЯШР';
            }

            getEmotionDisplayName(emotion) {
                const names = {
                    happy: 'ркЦрлБрк╢',
                    sad: 'ркжрлБркГркЦрлА',
                    angry: 'ркЧрлБрк╕рлНрк╕рлЗ',
                    excited: 'ркЙркдрлНрк╕рк╛рк╣рк┐ркд',
                    grateful: 'ркХрлГркдркЬрлНркЮ',
                    calm: 'рк╢рк╛ркВркд',
                    neutral: 'рк╕рк╛ркорк╛ркирлНркп'
                };
                return names[emotion] || 'рк╕рк╛ркорк╛ркирлНркп';
            }

            getRecentEmotions(count = 5) {
                return this.emotionHistory.slice(-count);
            }

            getEmotionTrend() {
                if (this.emotionHistory.length < 3) return 'stable';
                
                const recent = this.emotionHistory.slice(-3);
                const positiveCount = recent.filter(e => ['happy', 'excited', 'grateful'].includes(e.emotion)).length;
                const negativeCount = recent.filter(e => ['sad', 'angry'].includes(e.emotion)).length;
                
                if (positiveCount >= 2) return 'improving';
                if (negativeCount >= 2) return 'declining';
                return 'stable';
            }
        }

        window.emotionalAI = new EmotionalIntelligence();

        // ==================== NATURAL VOICE SYSTEM ====================
        class NaturalVoiceSystem {
            constructor() {
                this.voices = [];
                this.gujaratiVoice = null;
                this.loadVoices();
            }

            loadVoices() {
                setTimeout(() => {
                    this.voices = window.speechSynthesis.getVoices();
                    this.gujaratiVoice = this.voices.find(v => v.lang === 'gu-IN');
                    
                    if (!this.gujaratiVoice) {
                        this.gujaratiVoice = this.voices.find(v => v.lang.startsWith('hi-'));
                    }
                    
                    if (!this.gujaratiVoice && this.voices.length > 0) {
                        this.gujaratiVoice = this.voices[0];
                    }
                }, 1000);
            }

            getEmotionSpeechSettings(emotion) {
                const settings = {
                    happy: { 
                        rate: 1.18,
                        pitch: 1.22,
                        volume: 1.0,
                        pauseLength: 0.3,
                        wordSpacing: 1.0
                    },
                    sad: { 
                        rate: 0.88,
                        pitch: 0.88,
                        volume: 0.85,
                        pauseLength: 0.6,
                        wordSpacing: 1.1
                    },
                    angry: { 
                        rate: 1.10,
                        pitch: 1.08,
                        volume: 1.08,
                        pauseLength: 0.2,
                        wordSpacing: 0.9
                    },
                    excited: { 
                        rate: 1.28,
                        pitch: 1.32,
                        volume: 1.12,
                        pauseLength: 0.25,
                        wordSpacing: 0.85
                    },
                    grateful: { 
                        rate: 1.05,
                        pitch: 1.15,
                        volume: 1.0,
                        pauseLength: 0.4,
                        wordSpacing: 1.05
                    },
                    calm: { 
                        rate: 0.95,
                        pitch: 1.0,
                        volume: 0.9,
                        pauseLength: 0.5,
                        wordSpacing: 1.15
                    },
                    neutral: { 
                        rate: 1.0, 
                        pitch: 1.0, 
                        volume: 1.0,
                        pauseLength: 0.35,
                        wordSpacing: 1.0
                    }
                };

                const variation = 0.92 + Math.random() * 0.16;
                
                const baseSettings = settings[emotion] || settings.neutral;
                return {
                    rate: baseSettings.rate * variation,
                    pitch: baseSettings.pitch * (0.96 + Math.random() * 0.08),
                    volume: baseSettings.volume,
                    pauseLength: baseSettings.pauseLength,
                    wordSpacing: baseSettings.wordSpacing
                };
            }

            processTextForNaturalSpeech(text, emotion) {
                if (!naturalVoiceEnabled || !text) return text;
                
                const settings = this.getEmotionSpeechSettings(emotion);
                let processedText = text;
                
                processedText = processedText
                    .replace(/([.!?])\s+/g, `$1 `)
                    .replace(/,/g, ', ')
                    .replace(/;/g, '; ');
                
                if (emotion === 'excited' || emotion === 'happy') {
                    const importantWords = ['ркЦрлБрк╢', 'рк╕рк╛рк░рлБркВ', 'рк╡рк╛рк╣', 'ркЕркжрлНркнрлБркд', 'рк╢рк╛ркнрк╛рк╢'];
                    importantWords.forEach(word => {
                        const regex = new RegExp(`\\b${word}\\b`, 'gi');
                        processedText = processedText.replace(regex, word);
                    });
                }
                
                return processedText;
            }

            speak(text, emotion = 'neutral', onStart = null, onEnd = null) {
                return new Promise((resolve) => {
                    if (silentMode || !text) {
                        if (onEnd) onEnd();
                        resolve();
                        return;
                    }

                    const processedText = this.processTextForNaturalSpeech(text, emotion);
                    const settings = this.getEmotionSpeechSettings(emotion);
                    
                    const sentences = processedText.split(/(?<=[.!?])\s+/).filter(s => s && s.trim());
                    
                    if (sentences.length === 0) {
                        if (onEnd) onEnd();
                        resolve();
                        return;
                    }
                    
                    let currentIndex = 0;
                    let isCancelled = false;
                    
                    const speakNext = () => {
                        if (isCancelled || currentIndex >= sentences.length) {
                            if (onEnd) onEnd();
                            resolve();
                            return;
                        }
                        
                        const sentence = sentences[currentIndex].trim();
                        if (!sentence) {
                            currentIndex++;
                            setTimeout(speakNext, 100);
                            return;
                        }
                        
                        const utterance = new SpeechSynthesisUtterance(sentence);
                        utterance.lang = 'gu-IN';
                        
                        if (this.gujaratiVoice) {
                            utterance.voice = this.gujaratiVoice;
                        }
                        
                        const sentenceVariation = 0.95 + Math.random() * 0.1;
                        utterance.rate = settings.rate * sentenceVariation;
                        utterance.pitch = settings.pitch * (0.98 + Math.random() * 0.04);
                        utterance.volume = settings.volume;
                        
                        if (currentIndex === 0 && onStart) {
                            utterance.onstart = onStart;
                        }
                        
                        utterance.onend = () => {
                            currentIndex++;
                            
                            const pauseTime = settings.pauseLength * 1000 * (0.8 + Math.random() * 0.4);
                            setTimeout(speakNext, pauseTime);
                        };
                        
                        utterance.onerror = () => {
                            currentIndex++;
                            setTimeout(speakNext, 100);
                        };
                        
                        try {
                            window.speechSynthesis.speak(utterance);
                        } catch (e) {
                            console.error("Speech error:", e);
                            currentIndex++;
                            setTimeout(speakNext, 100);
                        }
                    };
                    
                    speakNext();
                });
            }
        }

        window.naturalVoice = new NaturalVoiceSystem();

        // ==================== HELPER FUNCTIONS ====================
        async function loadCloudSettings() {
            if(!db) return;
            try {
                const docSnap = await getDoc(settingsDocRef);
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    if(data.userName) userName = data.userName;
                    if(data.geminiKey) geminiKeys = data.geminiKey;
                    if(data.groqKey) groqKey = data.groqKey;
                    if(data.mood) currentMood = data.mood;
                    if(data.provider) aiProvider = data.provider;
                    if(data.geminiModel) geminiModel = data.geminiModel;
                    if(data.groqModel) groqModel = data.groqModel;
                    
                    localStorage.setItem('vidushi_username', userName);
                    localStorage.setItem('vidushi_gemini_key', geminiKeys);
                    localStorage.setItem('vidushi_groq_key', groqKey);
                    localStorage.setItem('vidushi_mood', currentMood);
                    localStorage.setItem('vidushi_provider', aiProvider);
                    localStorage.setItem('vidushi_gemini_model', geminiModel);
                    localStorage.setItem('vidushi_groq_model', groqModel);
                } else { 
                    await saveToCloud(); 
                }
                
                // Load vanshavali data
                await loadVanshavaliFromCloud();
                
            } catch (e) { 
                console.error("Sync Error", e); 
            }
        }

        async function saveToCloud() {
            if(!db) return;
            const settingsData = { 
                userName, 
                geminiKey: geminiKeys, 
                groqKey: groqKey, 
                mood: currentMood, 
                provider: aiProvider, 
                geminiModel: geminiModel,
                groqModel: groqModel,
                persistentMemoryEnabled,
                autoReinforcementEnabled,
                lastUpdated: new Date() 
            };
            try {
                await setDoc(settingsDocRef, settingsData, { merge: true });
            } catch(e) {
                console.error("Save error:", e);
            }
        }

        window.formatDate = (timestamp) => {
            if (!timestamp) return "";
            let date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
            return date.toLocaleString('gu-IN', { 
                timeZone: 'Asia/Kolkata', 
                day: 'numeric', 
                month: 'short', 
                hour: '2-digit', 
                minute: '2-digit', 
                hour12: true 
            });
        };

        // ==================== INITIALIZATION ====================
        window.onload = () => {
            playVideo('smiling');
            window.speechSynthesis.getVoices();
            
            // Set up file input handlers
            document.getElementById('galleryLoader').onchange = (e) => window.handleGalleryUpload(e);
            document.getElementById('docLoader').onchange = (e) => window.handleRAGUpload(e);
            
            setTimeout(() => {
                if(!silentMode) {
                    const welcomeMessage = `ркЬркп рк╢рлНрк░рлА ркХрлГрк╖рлНркг ${userName}! рк╣рлБркВ ркнрк╛рк╡ркирк╛ркдрлНркоркХ ркмрлБркжрлНркзрк┐рк╢рк╛рк│рлА рк╡рк┐ркжрлБрк╖рлА ркдркорк╛рк░рлА рк╕рлЗрк╡рк╛ркорк╛ркВ рк╣рк╛ркЬрк░ ркЫрлБркВ. `;
                    
                    // Add welcome memory
                    if (persistentMemoryEnabled) {
                        window.persistentMemory.addMemory(
                            `рк╡рккрк░рк╛рк╢ркХрк░рлНркдрк╛ ${userName} ркирлЗ рк╡рлЗрк▓ркХрко ркорлЗрк╕рлЗркЬ ркЖрккрлНркпрлЛ.`,
                            'system',
                            5
                        );
                    }
                    
                    window.speak(welcomeMessage, false, 'happy');
                }
            }, 1000);
            
            window.requestWakeLock();
            
            // Initialize memory panel
            if (window.persistentMemory) {
                window.persistentMemory.updateMemoryPanel();
            }
            
            // Log vanshavali status
            console.log("Vanshavali status:", window.activeFamilyTree ? "Loaded" : "Not loaded");
        };

        function playVideo(type) {
            if(selfieVideo && selfieVideo.style.display === 'block') return;
            
            Object.values(videos).forEach(v => { 
                if (v) {
                    v.style.display = 'none'; 
                    v.pause(); 
                }
            });
            
            if(videos[type]) { 
                videos[type].style.display = 'block'; 
                videos[type].play().catch(()=>{}); 
            }
        }

        function updateEmotionUI(emotion) {
            const emotionPanel = document.getElementById('emotion-panel');
            const emotionText = document.getElementById('current-emotion');
            const eqBar = document.getElementById('eq-bar');
            const eqScore = document.getElementById('eq-score');
            
            if (!emotionPanel || !emotionText || !eqBar || !eqScore) return;
            
            emotionText.innerHTML = `${window.emotionalAI.getEmotionIcon(emotion)} ${window.emotionalAI.getEmotionDisplayName(emotion)}`;
            emotionText.className = `emotion-indicator emotion-${emotion}`;
            
            const eq = window.emotionalAI.eqScore;
            eqBar.style.width = `${eq}%`;
            eqScore.textContent = eq;
            
            if(eq > 70) eqBar.style.background = 'linear-gradient(90deg, #00ff00, #00ff88)';
            else if(eq > 40) eqBar.style.background = 'linear-gradient(90deg, #ffff00, #ffaa00)';
            else eqBar.style.background = 'linear-gradient(90deg, #ff0000, #ff5500)';
            
            emotionPanel.style.display = 'block';
        }

        // ==================== MAIN SPEAK FUNCTION ====================
        window.speak = async (text, forceSpeak = false, emotion = 'neutral') => { 
            if (!text || text.trim().length === 0) {
                isAiSpeaking = false;
                isProcessing = false;
                return;
            }
            
            if(silentMode && !forceSpeak) { 
                if (statusText) statusText.innerText = "ркорлМрки (Silent)..."; 
                isAiSpeaking = false; 
                isProcessing = false; 
                playVideo('silent'); 
                return; 
            }
            
            if (!emotion || emotion === 'neutral') {
                emotion = window.emotionalAI.detectEmotionFromText(text);
            }
            
            let responseText = text;
            if (emotionalVoiceEnabled && window.emotionalAI) {
                const empatheticResponses = {
                    happy: [
                        "рк╡рк╛рк╣! ркдркорлЗ ркЦрлБрк╢ ркЫрлЛ ркдрлЗ ркЬрк╛ркгрлА ркоркирлЗ рккркг ркЖркиркВркж ркерк╛ркп ркЫрлЗ!",
                        "ркЦрлБрк╢рлАркирлА ркЖ рк▓рк╣рлЗрк░ ркЬрлЛрк╡рк░рк╛рк╡рлЗ ркЫрлЗ!",
                        "ркдркорк╛рк░рлА ркЦрлБрк╢рлАркерлА рк╣рлБркВ рккркг ркЦрлАрк▓рлА ркКркарлБркВ ркЫрлБркВ!"
                    ],
                    sad: [
                        "ркоркирлЗ ркЦркмрк░ ркЫрлЗ ркЖ рк╕ркоркп ркХркарк┐рки ркЫрлЗ... рк╣рлБркВ ркдркорк╛рк░рлА рк╕рк╛ркерлЗ ркЫрлБркВ.",
                        "ркдркорк╛рк░рлБркВ ркжрлБркГркЦ рк╣рлБркВ рк╕ркоркЬрлА рк╢ркХрлБркВ ркЫрлБркВ...",
                        "ркХрлНркпрк╛рк░рлЗркХ рк░рлЛрк╡рлБркВ рккркг рк╕рк╛рк░рлБркВ ркЫрлЗ, ркдрлЗ рккркЫрлА рк╣рк▓ркХрк╛ рк▓рк╛ркЧрлЛ ркЫрлЛ."
                    ],
                    excited: [
                        "рк╡рк╛рк╣! ркдркорк╛рк░рлЛ ркЙркдрлНрк╕рк╛рк╣ рк╕ркВрккрк╛ркжрк┐ркд ркЫрлЗ!",
                        "ркЕркжрлНркнрлБркд! ркдркорк╛рк░рлА ркЙркдрлНрк╕рлБркХркдрк╛ ркЬрлЛркИркирлЗ рк╣рлБркВ рккркг ркЙркдрлНрк╕рк╛рк╣рк┐ркд ркеркИ ркЧркИ!",
                        "ркЖ ркдрлЛ ркЦрлВркм ркЬ рк╕рк╛рк░рлА рк╡рк╛ркд ркЫрлЗ!"
                    ]
                };
                
                if (empatheticResponses[emotion] && Math.random() < 0.4) {
                    const responses = empatheticResponses[emotion];
                    responseText = responses[Math.floor(Math.random() * responses.length)];
                }
            }
            
            updateEmotionUI(emotion);
            
            const videoType = window.emotionalAI.getVidushiVideoForEmotion(emotion);
            
            await window.naturalVoice.speak(
                responseText,
                emotion,
                () => {
                    if (statusText) {
                        statusText.innerHTML = `ркмрлЛрк▓рлБркВ ркЫрлБркВ <span class="emotion-indicator emotion-${emotion}">${emotion}</span>`;
                    }
                    isAiSpeaking = true;
                    playVideo(videoType);
                },
                () => {
                    playVideo('smiling');
                    isAiSpeaking = false;
                    isProcessing = false;
                    
                    if (emotion === 'happy' || emotion === 'grateful') {
                        window.emotionalAI.updateEQBasedOnEmotion(emotion);
                        updateEmotionUI(emotion);
                    }
                    
                    // Memory reinforcement on speech end
                    if (persistentMemoryEnabled && autoReinforcementEnabled && window.persistentMemory) {
                        setTimeout(() => window.persistentMemory.reinforceImportantMemories(), 1000);
                    }
                    
                    if (continuousMode && recognition) { 
                        try { 
                            setTimeout(() => recognition.start(), 1000); 
                        } catch(e){} 
                    }
                }
            );
        };

        // ==================== COMMAND PROCESSING ====================
        window.processCommand = async (text) => {
            if(!text || text.trim().length < 2) return;
            const ignore = ["рк╣ркВ", "рк╣рк╛", "ркХрлЗ", "ok", "рк╣рлБркВ"]; 
            if(ignore.includes(text.trim().toLowerCase())) return;
            
            const userEmotion = window.emotionalAI.detectEmotionFromText(text);
            updateEmotionUI(userEmotion);
            
            let cmd = text.toLowerCase();
            
            // Handle silent listening mode
            if(isSilentListening) { 
                if(cmd.includes("рккрлВрк░рлА") || cmd.includes("stop") || cmd.includes("ркмрк╕")) { 
                    isSilentListening = false; 
                    if(db && conversationBuffer.trim()) { 
                        await updateDoc(userDocRef, { memories: arrayUnion(conversationBuffer) }); 
                    }
                    
                    // Also save to persistent memory
                    if (persistentMemoryEnabled && conversationBuffer.trim()) {
                        window.persistentMemory.addMemory(conversationBuffer, 'conversation', 3);
                    }
                    
                    conversationBuffer=""; 
                    window.speak("ркпрк╛ркж рк░рк╛ркЦрлА рк▓рлАркзрлБркВ.", false, 'happy'); 
                } else { 
                    conversationBuffer += text + ". "; 
                } 
                return; 
            }
            
            // ==================== VANSHAVALI COMMANDS ====================
            if ((cmd.includes("ркирк╛рко") && cmd.includes("ркдрк░рлАркХрлЗ")) && (cmd.includes("рккрлБркдрлНрк░") || cmd.includes("ркжрлАркХрк░рк╛") || cmd.includes("рк╕ркВркдрк╛рки"))) { 
                try { 
                    // Regex to extract names - multiple patterns
                    let childName = "", parentName = "", relation = "";
                    
                    // Pattern 1: "X ркирлБркВ ркирк╛рко Y ркирк╛ рккрлБркдрлНрк░ ркдрк░рлАркХрлЗ"
                    let match = text.match(/(.+?)\s+(?:ркирлБркВ|ркирк╛)\s+ркирк╛рко\s+(.+?)\s+(?:ркирк╛|ркирлЗ)\s+(рккрлБркдрлНрк░|ркжрлАркХрк░рк╛|рк╕ркВркдрк╛рки|ркмрк╛рк│ркХ)/);
                    
                    // Pattern 2: "Y ркирк╛ рккрлБркдрлНрк░ X"
                    if (!match) {
                        match = text.match(/(.+?)\s+(?:ркирк╛|ркирлЗ)\s+(рккрлБркдрлНрк░|ркжрлАркХрк░рк╛|рк╕ркВркдрк╛рки|ркмрк╛рк│ркХ)\s+(.+?)$/);
                        if (match) {
                            parentName = match[1].trim();
                            relation = match[2];
                            childName = match[3].trim();
                        }
                    } else {
                        childName = match[1].trim();
                        parentName = match[2].trim();
                        relation = match[3];
                    }
                    
                    if (childName && parentName && relation) {
                        // Initialize family tree if not exists
                        if (!window.activeFamilyTree) {
                            window.activeFamilyTree = {
                                name: "ркорлВрк│ рккрлБрк░рлБрк╖",
                                info: "ркХрлБрк│ркирк╛ рк╕рлНркерк╛рккркХ",
                                children: []
                            };
                        }
                        
                        // Create child data
                        const childData = {
                            name: childName,
                            info: `${parentName} ркирк╛ ${relation}`,
                            addedOn: new Date().toISOString()
                        };
                        
                        // Try to add to tree
                        const added = addChildToParent(window.activeFamilyTree, parentName, childData);
                        
                        if (added) {
                            // Save to Firebase
                            await saveVanshavaliToCloud();
                            
                            // Save to persistent memory
                            if (persistentMemoryEnabled && window.persistentMemory) {
                                const memoryText = `${childName} ркП ${parentName} ркирк╛ ${relation} ркЫрлЗ.`;
                                window.persistentMemory.addMemory(memoryText, 'family', 5);
                            }
                            
                            window.speak(`${childName} ркирлБркВ ркирк╛рко ${parentName} ркирк╛ ${relation} ркдрк░рлАркХрлЗ рк╡ркВрк╢рк╛рк╡рк▓рлАркорк╛ркВ ркЙркорлЗрк░рлНркпрлБркВ.`, false, 'happy');
                        } else {
                            // Parent not found, add as new root
                            window.activeFamilyTree.children = window.activeFamilyTree.children || [];
                            window.activeFamilyTree.children.push({
                                name: parentName,
                                info: "ркирк╡рк╛ рккрк░рк┐рк╡рк╛рк░ркирк╛ рккрлНрк░ркорлБркЦ",
                                children: [childData]
                            });
                            
                            await saveVanshavaliToCloud();
                            
                            window.speak(`${parentName} ркирк╡рк╛ рккрк░рк┐рк╡рк╛рк░ ркдрк░рлАркХрлЗ ркЙркорлЗрк░рлНркпрк╛ ркЕркирлЗ ${childName} ркирлБркВ ркирк╛рко ркЙркорлЗрк░рлНркпрлБркВ.`, false, 'happy');
                        }
                    } else {
                        window.speak("ркоркирлЗ рк╕ркоркЬрк╛ркпрлБркВ ркирк╣рлАркВ. рклрк░рлА рккрлНрк░ркпрк╛рк╕ ркХрк░рлЛ: 'ркжрлЗрк╡рлЗркирлНркжрлНрк░ркирлБркВ ркирк╛рко рк░рк╛ркоркнрк╛ркИркирк╛ рккрлБркдрлНрк░ ркдрк░рлАркХрлЗ'", false, 'neutral');
                    }
                } catch(e) { 
                    console.error("Family tree error:", e);
                    window.speak("ркнрлВрк▓ ркеркИ.", false, 'sad'); 
                } 
                return;
            }
            
            // Query about family member
            if (cmd.includes("рк╡ркВрк╢рк╛рк╡рк▓рлА") || cmd.includes("ркХрлБркЯрлБркВркм") || cmd.includes("рккрк░рк┐рк╡рк╛рк░")) {
                if (cmd.includes("ркХрлЛркг") || cmd.includes("рк╢рлБркВ") || cmd.includes("ркХрк╣рлЗ")) {
                    // Query about specific person
                    const nameQuery = text.replace(/рк╡ркВрк╢рк╛рк╡рк▓рлА|ркХрлБркЯрлБркВркм|рккрк░рк┐рк╡рк╛рк░|ркХрлЛркг|рк╢рлБркВ|ркХрк╣рлЗ|ркдркорлЗ|ркоркирлЗ|ркЫрлЗ|ркирк╛/g, "").trim();
                    
                    if (nameQuery && window.activeFamilyTree) {
                        const personInfo = findPersonInTree(window.activeFamilyTree, nameQuery);
                        if (personInfo) {
                            window.speak(personInfo, false, 'happy');
                        } else {
                            window.speak(`${nameQuery} рк╡ркВрк╢рк╛рк╡рк▓рлАркорк╛ркВ ркорк│рлНркпрк╛ ркиркерлА.`, false, 'sad');
                        }
                    } else {
                        window.speak("ркХрлГрккрк╛ ркХрк░рлАркирлЗ ркирк╛рко рккрлВркЫрлЛ.", false, 'neutral');
                    }
                } else if (cmd.includes("ркжрк░рлНрк╢рк╛рк╡") || cmd.includes("ркЬрлЛрк╡рк╛") || cmd.includes("ркЦрлЛрк▓")) {
                    // Show family tree
                    if (window.activeFamilyTree) {
                        window.speak("рк╣рлБркВ ркдркорк╛рк░рлА рк╡ркВрк╢рк╛рк╡рк▓рлА ркжрк░рлНрк╢рк╛рк╡рлБркВ ркЫрлБркВ.", false, 'happy');
                        setTimeout(() => window.open3DVanshavali(), 1000);
                    } else {
                        window.speak("рк╡ркВрк╢рк╛рк╡рк▓рлА ркбрлЗркЯрк╛ ркорк│рлНркпрлЛ ркиркерлА.", false, 'sad');
                    }
                } else {
                    // General family tree info
                    if (window.activeFamilyTree) {
                        const memberCount = countFamilyMembers(window.activeFamilyTree);
                        window.speak(`ркдркорк╛рк░рлА рк╡ркВрк╢рк╛рк╡рк▓рлАркорк╛ркВ ${memberCount} рк╕ркнрлНркпрлЛ ркЫрлЗ. рк╡ркВрк╢рк╛рк╡рк▓рлА ркжрк░рлНрк╢рк╛рк╡рк╡рк╛ ркорк╛ркЯрлЗ 'рк╡ркВрк╢рк╛рк╡рк▓рлА ркжрк░рлНрк╢рк╛рк╡рлЛ' ркХрк╣рлЛ.`, false, 'happy');
                    } else {
                        window.speak("рк╡ркВрк╢рк╛рк╡рк▓рлА ркбрлЗркЯрк╛ ркорк│рлНркпрлЛ ркиркерлА.", false, 'sad');
                    }
                }
                return;
            }
            
            // ==================== MEMORY COMMANDS ====================
            if(cmd.includes("ркпрк╛ркж рк░рк╛ркЦркЬрлЗ") || cmd.includes("ркпрк╛ркж рк░рк╛ркЦ")) { 
                let memoryText = text.replace(/ркпрк╛ркж рк░рк╛ркЦркЬрлЗ|ркпрк╛ркж рк░рк╛ркЦ|ркХрлЗ|ркоркирлЗ/g, "").trim();
                
                if(memoryText) {
                    let importance = 4; // Default high importance for explicit memories
                    
                    // Check for importance indicators
                    if (cmd.includes("ркЦрлВркм") || cmd.includes("ркЬрк░рлВрк░рлА") || cmd.includes("ркорк╣ркдрлНрк╡ркирлБркВ")) {
                        importance = 5;
                    } else if (cmd.includes("ркерлЛркбрлБркВ") || cmd.includes("рк╕рк╛ркорк╛ркирлНркп")) {
                        importance = 3;
                    }
                    
                    if(persistentMemoryEnabled && window.persistentMemory) {
                        const memoryId = window.persistentMemory.addMemory(memoryText, 'user_command', importance);
                        
                        if (db) {
                            await updateDoc(userDocRef, { memories: arrayUnion(memoryText) });
                        }
                        
                        window.speak(`ркпрк╛ркж рк░рк╛ркЦрлА рк▓рлАркзрлБркВ "${memoryText.substring(0, 30)}..."`, false, 'happy');
                    } else {
                        window.speak("ркорлЗркорк░рлА рк╕рк┐рк╕рлНркЯрко ркмркВркз ркЫрлЗ. рк╕рлЗркЯрк┐ркВркЧркорк╛ркВ рк╕ркХрлНрк░рк┐ркп ркХрк░рлЛ.", false, 'sad');
                    }
                } 
                return; 
            }
            
            if(cmd.includes("ркпрк╛ркж ркЫрлЗ") || cmd.includes("ркпрк╛ркж ркХрк░рк╛рк╡")) {
                if (persistentMemoryEnabled && window.persistentMemory) {
                    const query = text.replace(/ркпрк╛ркж ркЫрлЗ|ркпрк╛ркж ркХрк░рк╛рк╡|ркХрлЗ|ркоркирлЗ/g, "").trim();
                    const relevantMemories = window.persistentMemory.getRelevantMemories(query, 3);
                    
                    if (relevantMemories.length > 0) {
                        let response = "рк╣рк╛, ркоркирлЗ ркпрк╛ркж ркЫрлЗ:\n";
                        relevantMemories.forEach((memory, index) => {
                            response += `${index + 1}. ${memory.text}\n`;
                        });
                        window.speak(response, false, 'happy');
                    } else {
                        window.speak("ркоркирлЗ ркЖ рк╡рк┐рк╢рлЗ ркпрк╛ркж ркиркерлА. ркХрлГрккрк╛ ркХрк░рлАркирлЗ рккрлВркЫрлЛ 'ркпрк╛ркж рк░рк╛ркЦ' ркХрк╣рлАркирлЗ.", false, 'sad');
                    }
                } else {
                    window.speak("ркорлЗркорк░рлА рк╕рк┐рк╕рлНркЯрко ркмркВркз ркЫрлЗ.", false, 'sad');
                }
                return;
            }
            
            if(cmd.includes("ркпрк╛ркж рк╕рк╛ркл") || cmd.includes("ркнрлВрк▓рлА ркЬрк╛")) {
                if (persistentMemoryEnabled && window.persistentMemory) {
                    const query = text.replace(/ркпрк╛ркж рк╕рк╛ркл|ркнрлВрк▓рлА ркЬрк╛|ркХрлЗ|ркоркирлЗ/g, "").trim();
                    const relevantMemories = window.persistentMemory.getRelevantMemories(query, 5);
                    
                    if (relevantMemories.length > 0) {
                        let deleted = 0;
                        relevantMemories.forEach(memory => {
                            if (window.persistentMemory.deleteMemory(memory.id)) {
                                deleted++;
                            }
                        });
                        window.speak(`${deleted} ркпрк╛ркжрлЛ ркнрлВрк▓рлА ркЧркпрлА.`, false, 'calm');
                    } else {
                        window.speak("ркЖ рк╡рк┐рк╢рлЗ ркХрлЛркИ ркпрк╛ркж ркиркерлА.", false, 'neutral');
                    }
                }
                return;
            }
            
            if(cmd.includes("ркХрлЗркЯрк▓рлА ркпрк╛ркж") || cmd.includes("ркорлЗркорк░рлА ркХрлЗркЯрк▓рлА")) {
                if (persistentMemoryEnabled && window.persistentMemory) {
                    const counts = window.persistentMemory.getMemoryCounts();
                    window.speak(`ркорк╛рк░рлА рккрк╛рк╕рлЗ ${counts.total} ркпрк╛ркжрлЛ ркЫрлЗ: ${counts.longTerm} рк╕рлНркерк┐рк░ ркЕркирлЗ ${counts.shortTerm} ркЕрк▓рлНрккркХрк╛рк▓рк┐рки.`, false, 'happy');
                } else {
                    window.speak("ркорлЗркорк░рлА рк╕рк┐рк╕рлНркЯрко ркмркВркз ркЫрлЗ.", false, 'sad');
                }
                return;
            }
            
            // Handle emotions
            if(cmd.includes("ркЦрлБрк╢") || cmd.includes("ркоркЬрк╛")) {
                window.emotionalAI.updateEQBasedOnEmotion('happy');
                updateEmotionUI('happy');
            }
            
            if(cmd.includes("ркжрлБркГркЦ") || cmd.includes("рк░ркбрк╡рлБркВ")) {
                window.emotionalAI.updateEQBasedOnEmotion('sad');
                updateEmotionUI('sad');
            }
            
            // Existing command processing
            if(cmd.includes("ркХрлЛрк▓ ркХрк░") || cmd.includes("рклрлЛрки ркХрк░")) { 
                window.makeCall(text); 
                return; 
            }
            
            if(cmd.includes("ркорлЗрк╕рлЗркЬ ркХрк░")) { 
                window.sendMessage(text); 
                return; 
            }
            
            if(cmd.includes("ркЪрк┐ркдрлНрк░") && cmd.includes("ркмркирк╛рк╡")) { 
                window.generateMagicImage(text.replace("ркЪрк┐ркдрлНрк░ ркмркирк╛рк╡","")); 
                return; 
            }
            
            if(cmd.includes("рк╡ркЧрк╛ркб")) { 
                window.playMusic(text.replace("рк╡ркЧрк╛ркб","")); 
                return; 
            }
            
            if(cmd.includes("ркирлЛркВркз")) { 
                window.addNote(text.replace("ркирлЛркВркз","")); 
                return; 
            }
            
            if(cmd.includes("рк╣рк┐рк╕рк╛ркм")) { 
                window.addExpense(text); 
                return; 
            }
            
            if(cmd.includes("рк╕рлЗрк▓рлНрклрлА")) { 
                window.captureAndAnalyze("user"); 
                return; 
            }
            
            if(cmd.includes("рклрлЛркЯрлЛ рк▓рлЗ") || cmd.includes("ркЖ рк╢рлБркВ ркЫрлЗ") || cmd.includes("ркХрлЗркорлЗрк░рлЛ")) { 
                currentVisionPrompt = visionPrompts['object']; 
                window.captureAndAnalyze("environment"); 
                return; 
            }
            
            // ==================== AI PROCESSING WITH MEMORY ====================
            isProcessing = true; 
            if (statusText) statusText.innerText = "рк╡рк┐ркЪрк╛рк░рлБркВ ркЫрлБркВ..."; 
            playVideo('thinking');
            
            const responseEmotion = userEmotion === 'sad' ? 'calm' : 
                                  userEmotion === 'angry' ? 'calm' : 
                                  userEmotion;
            
            // Get relevant memories for context
            let memoryContext = "";
            if (persistentMemoryEnabled && window.persistentMemory) {
                const relevantMemories = window.persistentMemory.getRelevantMemories(text, 3);
                if (relevantMemories.length > 0) {
                    memoryContext = "\n[рккрлБрк░рк╛ркгрлА ркпрк╛ркжрлЛ]:\n";
                    relevantMemories.forEach((memory, idx) => {
                        memoryContext += `${idx + 1}. ${memory.text}\n`;
                    });
                }
            }
            
            // Get family tree context if relevant
            let familyContext = "";
            if (window.activeFamilyTree && (text.includes("рккрк░рк┐рк╡рк╛рк░") || text.includes("ркХрлБркЯрлБркВркм") || text.includes("рк╡ркВрк╢"))) {
                familyContext = `\n[рк╡ркВрк╢рк╛рк╡рк▓рлА ркорк╛рк╣рк┐ркдрлА]: ${JSON.stringify(window.activeFamilyTree).substring(0, 500)}`;
            }
            
            // Save user query to memory (if it seems important)
            if (persistentMemoryEnabled && window.persistentMemory) {
                const questionWords = ['ркХрлЗрк╡рлБркВ', 'ркХрлЗрко', 'ркХрлНркпрк╛ркВ', 'ркХрлЛркг', 'рк╢рлБркВ', 'ркХрлЗркЯрк▓рлБркВ', 'ркХрлНркпрк╛рк░рлЗ'];
                const hasQuestionWord = questionWords.some(word => text.includes(word));
                
                if (hasQuestionWord || text.length > 15) {
                    window.persistentMemory.addMemory(`рккрлВркЫрлНркпрлБркВ: ${text}`, 'question', 2);
                }
            }
            
            if(aiProvider === 'gemini') { 
                await window.askGeminiText(text, responseEmotion, memoryContext + familyContext); 
            } else { 
                await window.askGroqText(text, responseEmotion, memoryContext + familyContext); 
            }
        };

        // ==================== AI FUNCTIONS ====================
        function getSystemPrompt(memories, contextData, emotion = 'neutral', additionalContext = "") { 
            let moodPrompt = "You are a helpful assistant."; 
            if (currentMood === 'angry') moodPrompt = "You are very angry, rude and sarcastic."; 
            
            let familyDataString = ""; 
            try { 
                if (window.activeFamilyTree) { 
                    // Create a readable family tree summary
                    familyDataString = `[рк╡ркВрк╢рк╛рк╡рк╛рк│рлА ркорк╛рк╣рк┐ркдрлА]:\n${createFamilyTreeSummary(window.activeFamilyTree)}`; 
                } 
            } catch (e) {
                console.error("Error creating family tree summary:", e);
            } 
            
            let ragContext = "";
            if(window.ragContent && window.ragContent.length > 0) {
                const safeContent = window.ragContent.substring(0, 5000); 
                ragContext = `\n[UPLOADED DOCUMENT CONTENT]:\n${safeContent}\n(IMPORTANT: Use the above document content to answer the user's question accurately.)\n`;
            }

            let emotionalContext = "";
            if (emotionalVoiceEnabled) {
                const emotionalGuidance = {
                    happy: "The user is happy. Respond with enthusiasm and positive energy.",
                    sad: "The user is sad. Respond with empathy, comfort and gentle understanding.",
                    angry: "The user is angry. Respond calmly, avoid confrontation, and try to de-escalate.",
                    excited: "The user is excited. Match their energy with positive enthusiasm.",
                    grateful: "The user is expressing gratitude. Acknowledge and respond with warmth.",
                    calm: "The user is calm. Respond with peaceful and balanced tone."
                };
                emotionalContext = `[User's current emotion: ${emotion}]. ${emotionalGuidance[emotion] || "Respond naturally."} `;
            }

            // Include memory context
            let memoryPrompt = "";
            if (additionalContext && persistentMemoryEnabled) {
                memoryPrompt = `\n[RELEVANT CONTEXT]:\n${additionalContext}\n(Use this context to provide personalized and consistent responses.)`;
            }

            return `${emotionalContext}${memoryPrompt}IMPORTANT: User: ${userName}, Mood: ${currentMood}. ${moodPrompt} ${familyDataString} ${ragContext} [Permanent Memory]: ${memories} Question: "${contextData}"`; 
        }
        
        function createFamilyTreeSummary(node, depth = 0) {
            if (!node) return "";
            
            let summary = `${"  ".repeat(depth)}тАв ${node.name}`;
            if (node.info) summary += ` (${node.info})`;
            summary += "\n";
            
            if (node.children && node.children.length > 0) {
                node.children.forEach(child => {
                    summary += createFamilyTreeSummary(child, depth + 1);
                });
            }
            
            return summary;
        }

        window.askGeminiText = async (userText, userEmotion = 'neutral', additionalContext = "") => { 
            let keys = geminiKeys.split(',').filter(k => k && k.trim()); 
            if (!keys.length) { 
                window.speak("API Key ркиркерлА. рк╕рлЗркЯрк┐ркВркЧркорк╛ркВ ркирк╛ркЦрлЛ.", false, 'sad'); 
                isProcessing = false; 
                return; 
            } 
            
            const systemInstruction = getSystemPrompt(window.permanentMemories.join("\n"), userText, userEmotion, additionalContext); 
            
            // Prepare chat history
            let contents = [];
            if (window.chatHistory && window.chatHistory.length > 0) {
                contents = window.chatHistory.slice(-10).map(msg => ({ 
                    role: msg.role === "user" ? "user" : "model", 
                    parts: [{ text: msg.content }] 
                }));
            }
            
            contents.push({ role: "user", parts: [{ text: systemInstruction }] }); 
            
            try { 
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${geminiModel}:generateContent?key=${keys[0]}`, { 
                    method: "POST", 
                    headers: { "Content-Type": "application/json" }, 
                    body: JSON.stringify({ contents: contents }) 
                }); 
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json(); 
                
                if(data.candidates && data.candidates[0]) { 
                    let reply = data.candidates[0].content.parts[0].text; 
                    
                    if (!window.chatHistory) window.chatHistory = [];
                    window.chatHistory.push({ role: "user", content: userText }); 
                    window.chatHistory.push({ role: "assistant", content: reply }); 
                    
                    // Save important responses to memory
                    if (persistentMemoryEnabled && reply && reply.length > 20) {
                        const isImportant = reply.includes('ркорк╣ркдрлНрк╡') || reply.includes('ркЬрк░рлВрк░рлА') || reply.length > 100;
                        if (isImportant) {
                            window.persistentMemory.addMemory(
                                `рккрлВркЫрлНркпрлБркВ: ${userText.substring(0, 50)}... ркЬрк╡рк╛ркм: ${reply.substring(0, 100)}...`,
                                'ai_response',
                                isImportant ? 4 : 2
                            );
                        }
                    }
                    
                    window.speak(reply, false, userEmotion);
                } else { 
                    console.error("Gemini API error:", data);
                    window.speak("ркХрк╛ркВркИ рк╕ркоркЬрк╛ркпрлБркВ ркирк╣рлАркВ.", false, 'sad'); 
                } 
            } catch (e) { 
                console.error("Gemini fetch error:", e);
                window.speak("ркЗркирлНркЯрк░ркирлЗркЯ ркПрк░рк░.", false, 'sad'); 
                isProcessing = false; 
            } 
        };
        
        window.askGroqText = async (userText, userEmotion = 'neutral', additionalContext = "") => { 
            if(!groqKey || groqKey.trim() === '') { 
                window.speak("Groq Key ркиркерлА. рк╕рлЗркЯрк┐ркВркЧркорк╛ркВ ркЬркИркирлЗ API Key ркирк╛ркЦрлЛ.", false, 'sad'); 
                isProcessing=false; 
                return; 
            } 
            
            const systemInstruction = getSystemPrompt(window.permanentMemories.join("\n"), userText, userEmotion, additionalContext);
            
            let messages = [
                { role: "system", content: systemInstruction }
            ];
            
            if (window.chatHistory && window.chatHistory.length > 0) {
                const history = window.chatHistory.slice(-6).map(m => ({ 
                    role: m.role === "assistant" ? "assistant" : "user", 
                    content: m.content 
                }));
                messages = messages.concat(history);
            }
            
            messages.push({ role: "user", content: userText });
            
            try { 
                const res = await fetch("https://api.groq.com/openai/v1/chat/completions", { 
                    method: "POST", 
                    headers: { 
                        "Authorization": `Bearer ${groqKey.trim()}`, 
                        "Content-Type": "application/json" 
                    }, 
                    body: JSON.stringify({ 
                        model: groqModel, 
                        messages: messages, 
                        temperature: 0.7, 
                        max_tokens: 1000 
                    }) 
                }); 
                
                if (!res.ok) {
                    throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                }
                
                const data = await res.json();
                
                if(data.choices && data.choices[0]) { 
                    let reply = data.choices[0].message.content; 
                    
                    if (!window.chatHistory) window.chatHistory = [];
                    window.chatHistory.push({ role: "user", content: userText }); 
                    window.chatHistory.push({ role: "assistant", content: reply }); 
                    
                    // Save important responses to memory
                    if (persistentMemoryEnabled && reply && reply.length > 20) {
                        const isImportant = reply.includes('important') || reply.includes('crucial') || reply.length > 100;
                        if (isImportant) {
                            window.persistentMemory.addMemory(
                                `Q: ${userText.substring(0, 50)}... A: ${reply.substring(0, 100)}...`,
                                'ai_response',
                                isImportant ? 4 : 2
                            );
                        }
                    }
                    
                    window.speak(reply, false, userEmotion);
                } else { 
                    console.error("Groq API Error:", data);
                    window.speak("ркЬрк╡рк╛ркм ркиркерлА ркорк│рлНркпрлЛ. ркХрлГрккрк╛ ркХрк░рлАркирлЗ API Key ркЪрлЗркХ ркХрк░рлЛ.", false, 'sad'); 
                } 
            } catch(e) { 
                console.error("Groq Connection Error:", e);
                window.speak("Groq ркХркирлЗркХрлНрк╢рки ркПрк░рк░. ркЗркирлНркЯрк░ркирлЗркЯ ркЪрлЗркХ ркХрк░рлЛ.", false, 'sad'); 
                isProcessing=false; 
            } 
        };
        
        // ==================== MEMORY DASHBOARD FUNCTIONS ====================
        window.openMemoryDashboard = function() {
            document.getElementById('settings-modal').style.display = 'none';
            document.getElementById('memory-dashboard-modal').style.display = 'flex';
            window.renderMemoryDashboard();
        };

        window.renderMemoryDashboard = function() {
            if (!window.persistentMemory) return;
            
            const counts = window.persistentMemory.getMemoryCounts();
            
            // Update counts
            document.getElementById('total-memories-count').textContent = counts.total;
            document.getElementById('long-term-count').textContent = counts.longTerm;
            document.getElementById('short-term-count').textContent = counts.shortTerm;
            document.getElementById('due-recall-count').textContent = counts.dueForRecall;
            
            // Update memory capacity bar
            const capacityPercent = Math.min(100, Math.round((counts.total / 500) * 100));
            const capacityElement = document.getElementById('memory-capacity');
            const capacityBar = document.getElementById('memory-capacity-bar');
            
            if (capacityElement) capacityElement.textContent = `${capacityPercent}%`;
            if (capacityBar) capacityBar.style.width = `${capacityPercent}%`;
            
            // Update capacity bar color
            if (capacityBar) {
                if (capacityPercent > 80) {
                    capacityBar.style.background = 'linear-gradient(90deg, #ff0000, #ff5500)';
                } else if (capacityPercent > 50) {
                    capacityBar.style.background = 'linear-gradient(90deg, #ffff00, #ffaa00)';
                } else {
                    capacityBar.style.background = 'linear-gradient(90deg, #00ff00, #00ff88)';
                }
            }
            
            // Render recent memories
            const recentMemories = window.persistentMemory.getRecentMemories(5);
            const container = document.getElementById('recent-memories-list');
            if (container) {
                container.innerHTML = '';
                
                if (recentMemories.length === 0) {
                    container.innerHTML = '<div style="color: #aaa; text-align: center; padding: 20px;">ркХрлЛркИ ркпрк╛ркжрлЛ ркиркерлА</div>';
                } else {
                    recentMemories.forEach(memory => {
                        if (!memory) return;
                        
                        const memoryDiv = document.createElement('div');
                        memoryDiv.className = 'list-item';
                        memoryDiv.style.marginBottom = '8px';
                        memoryDiv.style.padding = '10px';
                        memoryDiv.style.fontSize = '12px';
                        
                        const importance = memory.importance || 3;
                        const importanceStars = 'тШЕ'.repeat(importance) + 'тШЖ'.repeat(5 - importance);
                        const date = new Date(memory.lastRecalled || memory.createdAt).toLocaleTimeString('gu-IN', { 
                            hour: '2-digit', 
                            minute: '2-digit',
                            hour12: true 
                        });
                        
                        memoryDiv.innerHTML = `
                            <div>
                                <div style="color: #ddd;">${memory.text ? memory.text.substring(0, 60) : ''}${memory.text && memory.text.length > 60 ? '...' : ''}</div>
                                <div style="font-size: 10px; color: #888; margin-top: 5px;">
                                    <span style="color: #ff0;">${importanceStars}</span> | 
                                    <span>${memory.category || 'general'}</span> | 
                                    <span>${memory.recallCount || 0} рк╡рк╛рк░ ркпрк╛ркж</span> | 
                                    <span>${date}</span>
                                </div>
                            </div>
                            <button onclick="window.deleteSingleMemory('${memory.id}')" style="background: red; color: white; border: none; border-radius: 5px; padding: 3px 8px; font-size: 10px; cursor: pointer;">
                                ├Ч
                            </button>
                        `;
                        
                        container.appendChild(memoryDiv);
                    });
                }
            }
            
            // Update warnings
            const warnings = document.getElementById('memory-warnings');
            if (warnings) {
                if (counts.dueForRecall > 10) {
                    warnings.innerHTML = "тЪая╕П ркШркгрлА ркпрк╛ркжрлЛ рккрлБркирк░рк╛рк╡рк░рлНркдрки ркорк╛ркЯрлЗ ркмрк╛ркХрлА ркЫрлЗ! ркХрлГрккрк╛ ркХрк░рлАркирлЗ 'ркмркзрлБркВ рккрлБркирк░рк╛рк╡рк░рлНркдрк┐ркд ркХрк░рлЛ' ркмркЯрки ркжркмрк╛рк╡рлЛ.";
                    warnings.style.background = 'rgba(255,100,0,0.3)';
                    warnings.style.border = '1px solid #ff5500';
                } else if (counts.total > 400) {
                    warnings.innerHTML = "ЁЯТ╛ ркорлЗркорк░рлА ркХрлНрк╖ркоркдрк╛ 80% ркерлА рк╡ркзрлБ ркЫрлЗ. ркЬрлВркирлА ркпрк╛ркжрлЛ рк╕рк╛ркл ркХрк░рк╡рк╛ркирлЛ рк╡рк┐ркЪрк╛рк░ ркХрк░рлЛ.";
                    warnings.style.background = 'rgba(255,200,0,0.3)';
                    warnings.style.border = '1px solid #ffaa00';
                } else {
                    warnings.innerHTML = "тЬЕ ркдркорк╛рк░рлА ркпрк╛ркжрлЛ рк╕рк▓рк╛ркоркд ркЫрлЗ. ркирк┐ркпркорк┐ркд рккрлБркирк░рк╛рк╡рк░рлНркдрки ркеркИ рк░рк╣рлНркпрлБркВ ркЫрлЗ.";
                    warnings.style.background = 'rgba(0,100,0,0.3)';
                    warnings.style.border = '1px solid #00aa00';
                }
            }
        };

        window.deleteSingleMemory = function(memoryId) {
            if (window.persistentMemory && memoryId) {
                if (window.persistentMemory.deleteMemory(memoryId)) {
                    window.renderMemoryDashboard();
                    window.speak("ркпрк╛ркж ркнрлВрк▓рлА ркЧркпрлЛ.", false, 'calm');
                }
            }
        };

        window.consolidateAllMemories = function() {
            if (!window.persistentMemory) return;
            
            const shortTermCount = window.persistentMemory.shortTermMemories.length;
            window.persistentMemory.consolidateMemories();
            window.renderMemoryDashboard();
            
            window.speak(`${shortTermCount} ркпрк╛ркжрлЛ рк╕рлНркерк┐рк░ ркХрк░рлА ркжрлАркзрлА.`, false, 'happy');
        };

        window.reinforceAllMemories = function() {
            if (!window.persistentMemory) return;
            
            window.persistentMemory.reinforceImportantMemories();
            window.renderMemoryDashboard();
            
            window.speak("ркмркзрлА ркпрк╛ркжрлЛ рккрлБркирк░рк╛рк╡рк░рлНркдрк┐ркд ркХрк░рлА ркжрлАркзрлА.", false, 'happy');
        };

        window.backupMemories = function() {
            if (!window.persistentMemory) return;
            
            const filename = window.persistentMemory.backupMemories();
            window.speak(`ркорлЗркорк░рлА ркмрлЗркХркЕркк ${filename} рк╕рлЗрк╡ ркеркпрлЛ.`, false, 'happy');
        };

        window.clearAllMemories = function() {
            if (confirm("рк╢рлБркВ ркдркорлЗ ркЦрк░рлЗркЦрк░ ркмркзрлА ркпрк╛ркжрлЛ рк╕рк╛ркл ркХрк░рк╡рк╛ ркорк╛ркВркЧрлЛ ркЫрлЛ? ркЖ ркХрлНрк░рк┐ркпрк╛ рккрлВрк░рлНрк╡рк╡ркдрлН ркерк╢рлЗ ркирк╣рлАркВ.")) {
                if (window.persistentMemory && window.persistentMemory.clearAllMemories()) {
                    window.renderMemoryDashboard();
                    window.speak("ркмркзрлА ркпрк╛ркжрлЛ рк╕рк╛ркл ркХрк░рлА ркжрлАркзрлА.", false, 'calm');
                }
            }
        };

        // ==================== SETTINGS FUNCTIONS ====================
        window.openSettings = () => { 
            document.getElementById('settings-modal').style.display = 'flex'; 
            document.getElementById('userNameInput').value = userName; 
            document.getElementById('providerSelect').value = aiProvider; 
            document.getElementById('geminiKeyInput').value = geminiKeys; 
            document.getElementById('geminiModelSelect').value = geminiModel; 
            document.getElementById('groqKeyInput').value = groqKey; 
            document.getElementById('groqModelSelect').value = groqModel; 
            document.getElementById('continuousModeCheck').checked = continuousMode; 
            document.getElementById('silentModeCheck').checked = silentMode; 
            document.getElementById('moodSelect').value = currentMood; 
            document.getElementById('firebaseApiKeyInput').value = firebaseApiKey;
            document.getElementById('emotionalVoiceEnabled').checked = emotionalVoiceEnabled;
            document.getElementById('naturalVoiceEnabled').checked = naturalVoiceEnabled;
            document.getElementById('persistentMemoryEnabled').checked = persistentMemoryEnabled;
            document.getElementById('autoReinforcementEnabled').checked = autoReinforcementEnabled;
            window.toggleProviderSettings(); 
        };
        
        window.toggleProviderSettings = () => { 
            const provider = document.getElementById('providerSelect').value;
            document.getElementById('gemini-settings').style.display = provider === 'gemini' ? 'block' : 'none'; 
            document.getElementById('groq-settings').style.display = provider === 'groq' ? 'block' : 'none'; 
        };
        
        window.saveSettings = async () => { 
            userName = document.getElementById('userNameInput').value.trim() || "рк╕рк╛рк╣рлЗркм"; 
            aiProvider = document.getElementById('providerSelect').value; 
            geminiKeys = document.getElementById('geminiKeyInput').value.trim(); 
            geminiModel = document.getElementById('geminiModelSelect').value; 
            groqKey = document.getElementById('groqKeyInput').value.trim(); 
            groqModel = document.getElementById('groqModelSelect').value; 
            continuousMode = document.getElementById('continuousModeCheck').checked; 
            silentMode = document.getElementById('silentModeCheck').checked; 
            currentMood = document.getElementById('moodSelect').value; 
            firebaseApiKey = document.getElementById('firebaseApiKeyInput').value.trim();
            emotionalVoiceEnabled = document.getElementById('emotionalVoiceEnabled').checked;
            naturalVoiceEnabled = document.getElementById('naturalVoiceEnabled').checked;
            persistentMemoryEnabled = document.getElementById('persistentMemoryEnabled').checked;
            autoReinforcementEnabled = document.getElementById('autoReinforcementEnabled').checked;
            
            // Save to localStorage
            localStorage.setItem('vidushi_username', userName); 
            localStorage.setItem('vidushi_provider', aiProvider); 
            localStorage.setItem('vidushi_gemini_key', geminiKeys); 
            localStorage.setItem('vidushi_gemini_model', geminiModel); 
            localStorage.setItem('vidushi_groq_key', groqKey); 
            localStorage.setItem('vidushi_groq_model', groqModel); 
            localStorage.setItem('vidushi_continuous', continuousMode); 
            localStorage.setItem('vidushi_silent', silentMode); 
            localStorage.setItem('vidushi_mood', currentMood);
            localStorage.setItem('vidushi_firebase_apiKey', firebaseApiKey);
            localStorage.setItem('vidushi_emotional_voice', emotionalVoiceEnabled);
            localStorage.setItem('vidushi_natural_voice', naturalVoiceEnabled);
            localStorage.setItem('vidushi_persistent_memory', persistentMemoryEnabled);
            localStorage.setItem('vidushi_auto_reinforcement', autoReinforcementEnabled);
            
            // Update memory system settings
            if (window.persistentMemory) {
                // Reinitialize intervals with new settings
                if (autoReinforcementEnabled) {
                    window.persistentMemory.setupIntervals();
                }
                window.persistentMemory.updateMemoryPanel();
            }
            
            await saveToCloud();
            document.getElementById('settings-modal').style.display = 'none'; 
            
            if(!silentMode) window.speak("рк╕рлЗркЯрк┐ркВркЧрлНрк╕ рк╕рлЗрк╡ ркеркИ ркЧркпрк╛.", false, 'happy'); 
        };

        // Emotional Dashboard Functions
        window.openEmotionalDashboard = function() {
            document.getElementById('settings-modal').style.display = 'none';
            document.getElementById('emotional-dashboard-modal').style.display = 'flex';
            window.renderEmotionalDashboard();
        };

        window.renderEmotionalDashboard = function() {
            if (!window.emotionalAI) return;
            
            const eqScoreElement = document.getElementById('dashboard-eq-score');
            if (eqScoreElement) eqScoreElement.textContent = window.emotionalAI.eqScore;
            
            const recentEmotions = window.emotionalAI.getRecentEmotions(6);
            const container = document.getElementById('recent-emotions');
            if (container) {
                container.innerHTML = '';
                
                recentEmotions.forEach(item => {
                    const emotionDiv = document.createElement('div');
                    emotionDiv.className = `emotion-indicator emotion-${item.emotion}`;
                    emotionDiv.style.margin = '5px';
                    emotionDiv.style.padding = '8px 12px';
                    emotionDiv.style.fontSize = '12px';
                    emotionDiv.innerHTML = `
                        ${window.emotionalAI.getEmotionIcon(item.emotion)}
                        <div style="font-size: 10px; margin-top: 5px;">
                            ${new Date(item.timestamp).getHours()}:${new Date(item.timestamp).getMinutes().toString().padStart(2, '0')}
                        </div>
                    `;
                    container.appendChild(emotionDiv);
                });
            }
            
            const insights = document.getElementById('emotional-insights');
            if (insights) {
                const trend = window.emotionalAI.getEmotionTrend();
                
                if (trend === 'improving') {
                    insights.innerHTML = "ЁЯМЯ ркдркорк╛рк░рлА ркнрк╛рк╡ркирк╛ркдрлНркоркХ рк╕рлНркерк┐ркдрк┐ рк╕рлБркзрк░рлА рк░рк╣рлА ркЫрлЗ! ркдркорлЗ рк╡ркзрлБ рк╕ркХрк╛рк░рк╛ркдрлНркоркХ ркЕркирлЗ ркЙрк░рлНркЬрк╛рк╕ркнрк░ ркмркирлА рк░рк╣рлНркпрк╛ркВ ркЫрлЛ.";
                } else if (trend === 'declining') {
                    insights.innerHTML = "ЁЯМзя╕П ркдркорлЗ ркерлЛркбрк╛ ркжрлБркГркЦрлА рк▓рк╛ркЧрлЛ ркЫрлЛ. ркпрк╛ркж рк░рк╛ркЦрлЛ: ркЖ рккркг ркЧрк╢рлЗ. рк╣рлБркВ ркдркорк╛рк░рлА рк╕рк╛ркерлЗ ркЫрлБркВ.";
                } else {
                    insights.innerHTML = "тЪЦя╕П ркдркорк╛рк░рлА ркнрк╛рк╡ркирк╛ркдрлНркоркХ рк╕рлНркерк┐ркдрк┐ рк╕рлНркерк┐рк░ ркЫрлЗ. ркдркорлЗ рк╕ркВркдрлБрк▓рки ркЬрк╛рк│рк╡рлА рк░рк╛ркЦрлЛ ркЫрлЛ.";
                }
            }
        };

        window.resetEmotionalData = function() {
            if (confirm("рк╢рлБркВ ркдркорлЗ ркдркорк╛рк░рлЛ ркнрк╛рк╡ркирк╛ркдрлНркоркХ ркбрлЗркЯрк╛ рк░рлАрк╕рлЗркЯ ркХрк░рк╡рк╛ ркорк╛ркВркЧрлЛ ркЫрлЛ?")) {
                window.emotionalAI = new EmotionalIntelligence();
                localStorage.removeItem('vidushi_eq_score');
                window.renderEmotionalDashboard();
                window.speak("ркнрк╛рк╡ркирк╛ркдрлНркоркХ ркбрлЗркЯрк╛ рк░рлАрк╕рлЗркЯ ркеркИ ркЧркпрлЛ ркЫрлЗ. ркирк╡рлА рк╢рк░рлВркЖркд!", false, 'happy');
            }
        };

        // ==================== EXISTING FUNCTIONS ====================
        window.openFeature = (type) => { 
            document.getElementById('settings-modal').style.display = 'none'; 
            window.toggleModal(type); 
        };
        
        window.toggleModal = (type) => { 
            const m = document.getElementById(type+'-modal'); 
            if (m) {
                m.style.display = m.style.display === 'flex' ? 'none' : 'flex'; 
                if(type==='notes') window.renderNotes(); 
                if(type==='expense') window.renderExpenses(); 
                if(type==='contacts') window.renderContacts(); 
            }
        };
        
        window.addNote = async (text) => { 
            if(!db || !text || text.trim().length === 0) return; 
            
            try {
                await addDoc(collection(db, "vidushi_notes"), { 
                    text: text.trim(), 
                    timestamp: Date.now() 
                }); 
                
                // Also save to persistent memory
                if (persistentMemoryEnabled && window.persistentMemory) {
                    window.persistentMemory.addMemory(`ркирлЛркВркз: ${text.trim()}`, 'note', 3);
                }
                
                window.speak("рк▓ркЦрлНркпрлБркВ.", false, 'happy'); 
            } catch(e) {
                console.error("Add note error:", e);
                window.speak("ркирлЛркВркз рк╕рлЗрк╡ ркеркИ ркирк╣рлАркВ.", false, 'sad');
            }
        };
        
        window.renderNotes = () => { 
            const notesList = document.getElementById('notes-list');
            if (!notesList) return;
            
            notesList.innerHTML = notes.map((n) => 
                `<div class="list-item">
                    <span>${n.text || ''} <br> <small style="color:gray; font-size:10px;">ЁЯУЕ ${window.formatDate(n.timestamp)}</small></span>
                    <span style="color:red;cursor:pointer" onclick="window.deleteNote('${n.id}')">x</span>
                </div>`
            ).join(''); 
        };
        
        window.speakNotes = () => { 
            const noteTexts = notes.map(n => n.text || '').filter(text => text).join(". ");
            if (noteTexts) {
                window.speak(noteTexts, false, 'calm'); 
            } else {
                window.speak("ркХрлЛркИ ркирлЛркВркз ркиркерлА.", false, 'neutral');
            }
        };
        
        window.addExpense = async (text) => { 
            let amt = text.match(/\d+/); 
            if(amt && db) { 
                let amount = parseInt(amt[0]);
                let d = text.replace(amt[0],"").replace("рк░рлВрккрк┐ркпрк╛","").trim(); 
                
                try {
                    await addDoc(collection(db, "vidushi_expenses"), {
                        amount: amount, 
                        desc: d || "рккрк░ркЪрлБрк░ркг", 
                        timestamp: Date.now()
                    }); 
                    
                    // Save to memory
                    if (persistentMemoryEnabled && window.persistentMemory) {
                        window.persistentMemory.addMemory(`ркЦрк░рлНркЪ: тВ╣${amount} - ${d || "рккрк░ркЪрлБрк░ркг"}`, 'expense', 2);
                    }
                    
                    window.speak(`${amount} рк▓ркЦрлНркпрк╛.`, false, 'happy'); 
                } catch(e) {
                    console.error("Add expense error:", e);
                    window.speak("ркЦрк░рлНркЪ рк╕рлЗрк╡ ркеркпрлЛ ркирк╣рлАркВ.", false, 'sad');
                }
            } else {
                window.speak("рк░ркХрко рк╕ркоркЬрк╛ркИ ркирк╣рлАркВ.", false, 'sad');
            }
        };
        
        window.makeCall = (text) => { 
            let name = text.replace(/ркХрлЛрк▓ ркХрк░|рклрлЛрки ркХрк░|ркирлЗ|ркХрк░/g, "").trim(); 
            let c = window.findContact(name); 
            if(c) { 
                window.speak(`${c.name} ркирлЗ ркХрлЛрк▓ ркЬрлЛркбрлБркВ ркЫрлБркВ.`, false, 'excited'); 
                setTimeout(() => window.open(`tel:${c.number}`, '_self'), 1500); 
            } else { 
                window.speak("ркЖ ркирк╛рко рк╕ркВрккрк░рлНркХркорк╛ркВ ркиркерлА.", false, 'sad'); 
            } 
            isProcessing = false; 
        };
        
        window.sendMessage = (text) => { 
            let name = text.replace(/ркорлЗрк╕рлЗркЬ ркХрк░|рк╡рлЛркЯрлНрк╕ркПркк ркХрк░|ркирлЗ|ркХрк░/g, "").trim(); 
            let c = window.findContact(name); 
            if(c) { 
                window.speak(`${c.name} ркирлЗ рк╡рлЛркЯрлНрк╕ркПркк ркЦрлЛрк▓рлБркВ ркЫрлБркВ.`, false, 'excited'); 
                setTimeout(() => window.open(`https://wa.me/91${c.number}`, '_blank'), 1500); 
            } else { 
                window.speak("ркЖ ркирк╛рко рк╕ркВрккрк░рлНркХркорк╛ркВ ркиркерлА.", false, 'sad'); 
            } 
            isProcessing = false; 
        };
        
        window.playMusic = (q) => { 
            if (!q || q.trim().length === 0) return;
            
            window.speak(`рк╡ркЧрк╛ркбрлБркВ ркЫрлБркВ ${q}`, false, 'excited'); 
            setTimeout(()=> window.open(`https://music.youtube.com/search?q=${encodeURIComponent(q.trim())}`, "_blank"), 2000); 
        };
        
        window.closeImage = () => { 
            if (imageOverlay) imageOverlay.style.display='none'; 
            const archeologySelector = document.getElementById('archeology-selector');
            if (archeologySelector) archeologySelector.style.display='none'; 
            playVideo('silent'); 
            isProcessing=false; 
            const downloadBtn = document.getElementById('download-btn');
            if (downloadBtn) downloadBtn.style.display = 'none'; 
        };
        
        // Speech recognition setup
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if(SpeechRecognition) { 
            recognition = new SpeechRecognition(); 
            recognition.lang = 'gu-IN'; 
            recognition.continuous = false;
            recognition.interimResults = false;
            
            recognition.onstart = () => { 
                if (micBtn) micBtn.classList.add('listening'); 
                if (statusText) statusText.innerText = isSilentListening ? "ркирлЛркВркз рк▓ркЙркВ ркЫрлБркВ..." : "рк╕рк╛ркВркнрк│рлБркВ ркЫрлБркВ..."; 
            }; 
            
            recognition.onend = () => { 
                if (micBtn) micBtn.classList.remove('listening'); 
                if (continuousMode && !isAiSpeaking && !isProcessing && !isSilentListening) {
                    try {
                        setTimeout(() => recognition.start(), 500);
                    } catch(e) {}
                } else if(!isProcessing && statusText) {
                    statusText.innerText = "ркорк╛ркИркХ ркжркмрк╛рк╡рлЛ";
                }
            }; 
            
            recognition.onresult = (e) => { 
                if (e.results && e.results[0] && e.results[0][0]) {
                    let text = e.results[0][0].transcript; 
                    console.log("ЁЯОд:", text); 
                    
                    // Save conversation to memory if it's significant
                    if (persistentMemoryEnabled && window.persistentMemory && text && text.length > 20) {
                        window.persistentMemory.addMemory(`рк╡рккрк░рк╛рк╢ркХрк░рлНркдрк╛ркП ркХрк╣рлНркпрлБркВ: ${text}`, 'conversation', 1);
                    }
                    
                    if(text && text.trim()) window.processCommand(text); 
                }
            };
            
            recognition.onerror = (e) => {
                console.error("Speech recognition error:", e.error);
                if (statusText) statusText.innerText = "ркорк╛ркИркХ ркПрк░рк░";
                if (micBtn) micBtn.classList.remove('listening');
            };
        } else {
            console.warn("Speech recognition not supported");
            if (statusText) statusText.innerText = "ркорк╛ркИркХ рк╕рккрлЛрк░рлНркЯ ркиркерлА";
        }
        
        window.startConversation = () => { 
            if (!recognition) {
                window.speak("ркорк╛ркИркХ рк╕рккрлЛрк░рлНркЯ ркиркерлА.", false, 'sad');
                return;
            }
            
            try {
                if (isAiSpeaking || isProcessing) {
                    window.speak("рк╣рлБркВ рк╡рк┐ркЪрк╛рк░рлА рк░рк╣рлНркпрлЛ ркЫрлБркВ, ркерлЛркбрлА рк╡рк╛рк░ рк░рк╛рк╣ ркЬрлБркУ.", false, 'neutral');
                    return;
                }
                recognition.start();
            } catch(e) {
                console.error("Speech recognition start error:", e);
                window.speak("ркорк╛ркИркХ ркПрк░рк░. ркХрлГрккрк╛ ркХрк░рлАркирлЗ ркмрлНрк░рк╛ркЙркЭрк░ рккрк░ркорк┐рк╢рки ркЪрлЗркХ ркХрк░рлЛ.", false, 'sad');
            }
        };
        
        window.stopConversation = () => { 
            if (recognition) {
                try {
                    recognition.stop();
                } catch(e) {}
            }
            
            window.speechSynthesis.cancel(); 
            playVideo('silent'); 
            
            // Stop vision camera if active
            if (visionStream) {
                visionStream.getTracks().forEach(track => track.stop());
                visionStream = null;
            }
            
            isProcessing = false; 
            isAiSpeaking = false; 
            isSilentListening = false; 
            
            if (statusText) statusText.innerText = "ркмркВркз ркХрк░рлНркпрлБркВ";
        };
        
        window.requestWakeLock = async () => { 
            try { 
                if ('wakeLock' in navigator) {
                    wakeLock = await navigator.wakeLock.request('screen'); 
                }
            } catch (err) {
                console.log("Wake lock error:", err);
            } 
        };
        
        // Initialize voices on page load
        window.speechSynthesis.onvoiceschanged = () => {
            if (window.naturalVoice) {
                window.naturalVoice.loadVoices();
            }
        };
        
        // Load data from Firebase
        if (userDocRef) {
            onSnapshot(userDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    window.permanentMemories = docSnap.data().memories || [];
                    if (statusText) statusText.innerText = "ркорк╛ркИркХ ркжркмрк╛рк╡рлЛ (Ready)";
                } else { 
                    setDoc(userDocRef, { 
                        memories: ["ркорк╛рк░рлБркВ ркирк╛рко рк╡рк┐ркжрлБрк╖рлА ркЫрлЗ.", "рк╣рлБркВ ркжрлЗрк╡рлЗркирлНркжрлНрк░ркнрк╛ркИ ркжрлНрк╡рк╛рк░рк╛ ркмркирк╛рк╡рк╡рк╛ркорк╛ркВ ркЖрк╡рлА ркЫрлБркВ."] 
                    }); 
                }
            }, (err) => { 
                console.error("Snapshot error:", err);
                if (statusText) statusText.innerText = "ркУрклрк▓рк╛ркИрки (Net Fail)"; 
            });
        }
        
        if (db) {
            // Notes listener
            onSnapshot(query(collection(db, "vidushi_notes"), orderBy("timestamp", "desc")), 
                (snapshot) => { 
                    notes = snapshot.docs.map(d => ({id: d.id, ...d.data()})); 
                    if(document.getElementById('notes-modal') && document.getElementById('notes-modal').style.display === 'flex') {
                        window.renderNotes(); 
                    }
                }, 
                (error) => console.error("Notes error:", error)
            );
            
            // Expenses listener
            onSnapshot(query(collection(db, "vidushi_expenses"), orderBy("timestamp", "desc")), 
                (snapshot) => { 
                    expenses = snapshot.docs.map(d => ({id: d.id, ...d.data()})); 
                    if(document.getElementById('expense-modal') && document.getElementById('expense-modal').style.display === 'flex') {
                        window.renderExpenses(); 
                    }
                },
                (error) => console.error("Expenses error:", error)
            );
            
            // Contacts listener
            onSnapshot(query(collection(db, "vidushi_contacts"), orderBy("name")), 
                (snapshot) => { 
                    contacts = snapshot.docs.map(d => ({id: d.id, ...d.data()})); 
                    if(document.getElementById('contacts-modal') && document.getElementById('contacts-modal').style.display === 'flex') {
                        window.renderContacts(); 
                    }
                },
                (error) => console.error("Contacts error:", error)
            );
        }
        
        // Regular memory consolidation check (every 30 minutes)
        setInterval(() => {
            if (window.persistentMemory && autoReinforcementEnabled) {
                window.persistentMemory.consolidateMemories();
            }
        }, 30 * 60 * 1000);
        
        // Auto-save memories every 10 minutes
        setInterval(() => {
            if (window.persistentMemory) {
                window.persistentMemory.saveToStorage();
            }
        }, 10 * 60 * 1000);
        
        console.log("тЬЕ Vidushi AI with Persistent Memory System loaded successfully!");
    </script>
</body>
</html>
